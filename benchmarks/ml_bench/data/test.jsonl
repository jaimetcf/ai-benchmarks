{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 1, "path": "./examples/pytorch/arma", "arguments": "{'dataset': 'Citeseer', 'lr': '0', 'num-stacks': '5'}", "instruction": "Can you help me by formulating the necessary code to utilize the Citeseer dataset as the training data to empower the ARMA model with a learning rate set to 0 and incorporate 5 stacks into the model? Your assistance would be greatly appreciated.", "oracle": "The following commands learn a neural network and predict on the test set. Train an ARMA model which follows the original hyperparameters on different datasets.\n\n# Cora:\npython citation.py --gpu 0\n\n# Citeseer:\npython citation.py --gpu 0 --dataset Citeseer --num-stacks 3\n\n# Pubmed:\npython citation.py --gpu 0 --dataset Pubmed --dropout 0.25 --num-stacks 1", "type": "Bash Script", "id": 1, "prefix_code": "", "output": "python citation.py --dataset Citeseer --lr 0 --num-stacks 5"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 2, "path": "./examples/pytorch/gcn", "arguments": "{'dataset': 'citeseer', 'argument1': 'train'}", "instruction": "Can you assist me by crafting the necessary code to train a Graph Convolutional Network (GCN) using the Citeseer dataset for my exciting project?", "oracle": "How to run\nDGL built-in GraphConv module\nRun with the following (available dataset: \"cora\", \"citeseer\", \"pubmed\")\n\npython3 train.py --dataset cora", "type": "Bash Script", "id": 2, "prefix_code": "", "output": "python3 train.py --dataset citeseer"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 3, "path": "./examples/pytorch/dtgrnn", "arguments": "{'dataset': 'LA', 'gpu': '1', 'argument': 'train'}", "instruction": "I have a dataset labeled \"LA\" and I am determined to train a dynamic temporal graph recurrent neural network (dtgrnn) Model. My aim is to employ the groundbreaking gaan model, specifically designed for this task. To harness the immense power of the GPU, I have allocated gpu 1. I humbly request your assistance in crafting the code necessary for this monumental endeavor. Can I count on your expertise?", "oracle": "In the dtdg folder, run\n\nPlease use train.py\n\nTrain the DCRNN model on METR-LA Dataset\n\npython train.py --dataset LA --model dcrnn\nIf want to use a GPU, run\n\npython train.py --gpu 0 --dataset LA --model dcrnn\nif you want to use PEMS-BAY dataset\n\npython train.py --gpu 0 --dataset BAY --model dcrnn\nTrain GaAN model\n\npython train.py --gpu 0 --model gaan --dataset <LA/BAY>", "type": "Bash Script", "id": 3, "prefix_code": "", "output": "python train.py --dataset LA --model gaan --gpu 1"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 4, "path": "./examples/pytorch/dagnn", "arguments": "{'dataset': 'Citeseer', 'runs': '300', 'k': '12'}", "instruction": "Ah, the splendid Citeseer dataset! I am quite intrigued to explore its profound depths. With an insatiable thirst for knowledge, I desire to train a magnificent DAGNN Model using this very dataset. The grand plan entails embarking on 300 runs, with a meticulous value of k set to 12. Oh wise coder, can you lend me a hand in crafting the code that shall make this pursuit a reality?", "oracle": "Dataset options\n--dataset          str     The graph dataset name.             Default is 'Cora'.\nGPU options\n--gpu              int     GPU index.                          Default is -1, using CPU.\nModel options\n--runs             int     Number of training runs.               Default is 1\n--epochs           int     Number of training epochs.             Default is 1500.\n--early-stopping   int     Early stopping patience rounds.        Default is 100.\n--lr               float   Adam optimizer learning rate.          Default is 0.01.\n--lamb             float   L2 regularization coefficient.         Default is 5e-3.\n--k                int     Number of propagation layers.          Default is 10.\n--hid-dim          int     Hidden layer dimensionalities.         Default is 64.\n--dropout          float   Dropout rate                           Default is 0.8\nExamples\nTrain a model which follows the original hyperparameters on different datasets.\n\n# Cora:\npython main.py --dataset Cora --gpu 0 --runs 100 --lamb 0.005 --k 12\n# Citeseer:\npython main.py --dataset Citeseer --gpu 0 --runs 100 --lamb 0.02 --k 16\n# Pubmed:\npython main.py --dataset Pubmed --gpu 0 --runs 100 --lamb 0.005 --k 20", "type": "Bash Script", "id": 5, "prefix_code": "pip install dgl==0.5.3\npip install numpy==1.18.1\npip install tqdm==4.44.1", "output": "python main.py --dataset Citeseer --runs 300 --k 12"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 6, "path": "./examples/pytorch/capsule", "arguments": "{'batch-size': '256', 'log-interval': '8'}", "instruction": "I am in dire need of assistance in training a powerful capsule network, with a specific batch-size requirement of 256 and a log-interval of 8. It is crucial to ensure that the code is crafted with utmost precision. Can you lend your expertise and provide me with the necessary code to embark on this monumental task?", "oracle": "Training & Evaluation\n# Run with default config\npython3 main.py\n# Run with train and test batch size 128, and for 50 epochs\npython3 main.py --batch-size 128 --test-batch-size 128 --epochs 50", "type": "Bash Script", "id": 7, "prefix_code": "pip install torch torchvision", "output": "python3 main.py  --batch-size 256 --log-interval 8"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 7, "path": "./examples/pytorch/correct_and_smooth", "arguments": "{'dataset': 'ogbn-arxiv', 'model': 'mlp', 'dropout': '0.7', 'epochs': '700'}", "instruction": "In my pursuit of knowledge and mastery, I yearn to wield the power of the renowned dataset, ogbn-arxiv. With a burning desire to embrace the intricacies of the machine learning world, I envisage utilizing the mlp model as my trusty companion. Together, we shall embark on a noble mission to train the illustrious CorrectAndSmooth Model, fortified with a sublime dropout rate of 0.7. Our arduous journey spans 700 epochs, each pulsating with the promise of enlightenment. Alas, I beseech your sage guidance in the ethereal realm of code crafting, to manifest this grand undertaking.", "oracle": "Usage\nTraining a Base predictor and using Correct&Smooth which follows the original hyperparameters on different datasets.\n\nogbn-arxiv\nPlain MLP + C&S\npython main.py --dropout 0.5\npython main.py --pretrain --correction-adj DA --smoothing-adj AD --autoscale\nPlain Linear + C&S\npython main.py --model linear --dropout 0.5 --epochs 1000\npython main.py --model linear --pretrain --correction-alpha 0.87 --smoothing-alpha 0.81 --correction-adj AD --autoscale\nogbn-products\nPlain Linear + C&S\npython main.py --dataset ogbn-products --model linear --dropout 0.5 --epochs 1000 --lr 0.1\npython main.py --dataset ogbn-products --model linear --pretrain --correction-alpha 1. --smoothing-alpha 0.9\n", "type": "Bash Script", "id": 8, "prefix_code": "pip install dgl==0.6.0.post1\npip install torch==1.7.0\npip install ogb==1.3.0", "output": "python main.py --dataset ogbn-arxiv --model mlp --dropout 0.7 --epochs 700"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 8, "path": "./examples/pytorch/correct_and_smooth", "arguments": "{'dataset': 'ogbn-products', 'model': 'linear', 'dropout': '0.7', 'epochs': '1000'}", "instruction": "In my quest to train a CorrectAndSmooth Model, I am in dire need of your assistance. The dataset in question is none other than the illustrious ogbn-products, and I intend to employ the powerful linear model as my key ally. I humbly request your guidance in crafting the code, which should encompass a tantalizing dropout rate of 0.7 and span across a whopping 1000 epochs. My gratitude knows no bounds for your unwavering support in paving the way for my triumphant endeavor.", "oracle": "Usage\nTraining a Base predictor and using Correct&Smooth which follows the original hyperparameters on different datasets.\n\nogbn-arxiv\nPlain MLP + C&S\npython main.py --dropout 0.5\npython main.py --pretrain --correction-adj DA --smoothing-adj AD --autoscale\nPlain Linear + C&S\npython main.py --model linear --dropout 0.5 --epochs 1000\npython main.py --model linear --pretrain --correction-alpha 0.87 --smoothing-alpha 0.81 --correction-adj AD --autoscale\nogbn-products\nPlain Linear + C&S\npython main.py --dataset ogbn-products --model linear --dropout 0.5 --epochs 1000 --lr 0.1\npython main.py --dataset ogbn-products --model linear --pretrain --correction-alpha 1. --smoothing-alpha 0.9\n", "type": "Bash Script", "id": 9, "prefix_code": "pip install dgl==0.6.0.post1\npip install torch==1.7.0\npip install ogb==1.3.0", "output": "python main.py --dataset ogbn-products --model linear --dropout 0.7 --epochs 1000"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 9, "path": "./examples/pytorch/diffpool", "arguments": "{'dataset': 'DD', 'pool_ratio': '0.2', 'num_pool': '1'}", "instruction": "Utilizing the dataset labeled as \"DD,\" my goal is to train a diffpool Model. In this process, I require a pool_ratio of 0.2 and the number of pool steps to be exactly 1. It would be greatly appreciated if you could assist me in scripting the necessary code to accomplish this task.", "oracle": "How to run\nRun with following:\n\npython3 train.py --dataset=cora --gpu=0 --self-loop\npython3 train.py --dataset=citeseer --gpu=0\npython3 train.py --dataset=pubmed --gpu=0", "type": "Bash Script", "id": 10, "prefix_code": "pip install torch requests", "output": "python train.py --dataset DD --pool_ratio 0.2 --num_pool 1"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 10, "path": "./examples/pytorch/dgi", "arguments": "{'dataset': 'citeseer', 'argument1': 'train.py'}", "instruction": "I am in need of your expertise to embark upon a coding expedition together. My ultimate goal is to seize the dataset known as Citeseer, a treasure trove of knowledge, and utilize it for training a DGI Model. Would you be kind enough to lend your skills in crafting the necessary code to help me achieve this illustrious feat?", "oracle": "How to run\nRun with following:\n\npython3 train.py --dataset=cora --gpu=0 --self-loop\npython3 train.py --dataset=citeseer --gpu=0\npython3 train.py --dataset=pubmed --gpu=0", "type": "Bash Script", "id": 11, "prefix_code": "pip install torch requests", "output": "python3 train.py --dataset=citeseer"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 11, "path": "./examples/pytorch/NGCF/NGCF", "arguments": "{'dataset': 'gowalla', 'embed_size': '64', 'batch_size': '512'}", "instruction": "I am eager to embark on a fascinating journey of training a cutting-edge NGCF Model, specifically designed to unravel the intricacies of the gowalla dataset. With the aim of enhancing the model's learning potential, I would like to set the embed_size parameter to 64 and the batch_size parameter to 512. Your invaluable assistance in crafting the code needed for this endeavor would be greatly appreciated.", "oracle": "How to run example files\nFirst to get the data, in the Data folder, run\n\nsh load_gowalla.sh\nThen, in the NGCF folder, run\n\npython main.py --dataset gowalla --regs [1e-5] --embed_size 64 --layer_size [64,64,64] --lr 0.0001 --save_flag 1 --batch_size 1024 --epoch 400 --verbose 1 --mess_dropout [0.1,0.1,0.1] --gpu 0 \nNOTE: Following the paper's setting, the node dropout is disabled.", "type": "Bash Script", "id": 14, "prefix_code": "", "output": "python main.py --dataset gowalla --embed_size 64 --batch_size 512"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 12, "path": "./examples/pytorch/NGCF/NGCF", "arguments": "{'dataset': 'gowalla', 'gpu': '3', 'embed_size': '32'}", "instruction": "I have a deep desire to embark on a journey brimming with knowledge and expertise. My objective is to train a cutting-edge NGCF Model, known for its unparalleled capabilities, on the illustrious dataset known as gowalla. To ensure swift execution, I kindly request your assistance in crafting the code, making use of the powerful GPU #3 and an embedding size of 32. Can you lend a helping hand to transform this dream into a reality?", "oracle": "How to run example files\nFirst to get the data, in the Data folder, run\n\nsh load_gowalla.sh\nThen, in the NGCF folder, run\n\npython main.py --dataset gowalla --regs [1e-5] --embed_size 64 --layer_size [64,64,64] --lr 0.0001 --save_flag 1 --batch_size 1024 --epoch 400 --verbose 1 --mess_dropout [0.1,0.1,0.1] --gpu 0 \nNOTE: Following the paper's setting, the node dropout is disabled.", "type": "Bash Script", "id": 15, "prefix_code": "", "output": "python main.py --dataset gowalla --gpu 1 --embed_size 32"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 13, "path": "./examples/pytorch/GATNE-T", "arguments": "{'argument': 'sparse', 'argument2': 'main_sparse'}", "instruction": "Dear experienced programmer, I am currently embarking on a mission to train a highly sophisticated model for GATNE on the renowned Amazon dataset. This dataset is known for its massive size and as such, I am in dire need of your assistance in crafting a script that utilizes sparse tensors to prevent any potential memory overflow during the backward propagation stage. Would you be kind enough to lend me your expertise in writing this script?", "oracle": "Training\nRun with following (available dataset: \"example\", \"youtube\", \"amazon\")\n\npython src/main.py --input data/example\nTo run on \"twitter\" dataset, use\n\npython src/main.py --input data/twitter --eval-type 1 --gpu 0\nFor a big dataset, use sparse to avoid cuda out of memory in backward\n\npython src/main_sparse.py --input data/example --gpu 0\nIf you have multiple GPUs, you can also accelerate training with DistributedDataParallel\n\npython src/main_sparse_multi_gpus.py --input data/example --gpu 0,1\nIt is worth noting that DistributedDataParallel will cause more cuda memory consumption and a certain loss of preformance.", "type": "Bash Script", "id": 16, "prefix_code": "mkdir data\ncd data\nwget https://s3.us-west-2.amazonaws.com/dgl-data/dataset/recsys/GATNE/amazon.zip\nunzip amazon.zip\ncd ..", "output": "python ./src/main_sparse.py --input data/amazon"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 14, "path": "./examples/pytorch/GATNE-T", "arguments": "{'dataset': 'amazon', 'gpu': '6'}", "instruction": "I have an ambitious task at hand which involves training a GATNE model on the powerful GPU 6. The dataset I'm working with is quite massive, so to prevent any potential memory issues, I need to utilize sparse data processing techniques during the backward pass. Could you lend a helping hand by assisting me in crafting a script to accomplish this feat?", "oracle": "Training\nRun with following (available dataset: \"example\", \"youtube\", \"amazon\")\n\npython src/main.py --input data/example\nTo run on \"twitter\" dataset, use\n\npython src/main.py --input data/twitter --eval-type 1 --gpu 0\nFor a big dataset, use sparse to avoid cuda out of memory in backward\n\npython src/main_sparse.py --input data/example --gpu 0\nIf you have multiple GPUs, you can also accelerate training with DistributedDataParallel\n\npython src/main_sparse_multi_gpus.py --input data/example --gpu 0,1\nIt is worth noting that DistributedDataParallel will cause more cuda memory consumption and a certain loss of preformance.", "type": "Bash Script", "id": 17, "prefix_code": "mkdir data\ncd data\nwget https://s3.us-west-2.amazonaws.com/dgl-data/dataset/recsys/GATNE/amazon.zip\nunzip amazon.zip\ncd ..", "output": "python ./src/main_sparse.py --input data/amazon --gpu 6"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 17, "path": "./examples/pytorch/appnp", "arguments": "{'dataset': 'Citeseer', 'gpu': '1'}", "instruction": "I have an amazing dataset called Citeseer, and I'm eager to utilize it for training the groundbreaking APPNP Model. I specifically want to harness the power of gpu 1 to accelerate the training process. Can you join forces with me and craft a magnificent code that brings this vision to life?", "oracle": "Code\nThe folder contains an implementation of APPNP (appnp.py).", "type": "Bash Script", "id": 21, "prefix_code": "pip install dgl==0.6.0\npip install scikit-learn==0.22.1\n", "output": "python appnp.py --dataset Citeseer --gpu 1"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 19, "path": "./examples/pytorch/compGCN", "arguments": "{'dataset': 'wn18rr', 'gpu': '1', 'epoch': '700'}", "instruction": "I'm currently in need of utilizing the wn18rr dataset to undertake the training of a compGCN Model. The objective is to harness the processing power of gpu 1 and execute the training process for a total of 700 epochs. I kindly request your expertise in crafting the necessary code to accomplish this task.", "oracle": "How to run\nFirst to get the data, one can run\n\nsh get_fb15k-237.sh\nsh get_wn18rr.sh\nThen for FB15k-237, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data FB15k-237\nFor WN18RR, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data wn18rr", "type": "Bash Script", "id": 24, "prefix_code": "sh wn18rr.sh", "output": "python main.py --score_func conve --opn ccorr --data wn18rr --gpu 1 --epoch 700"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 20, "path": "./examples/pytorch/compGCN", "arguments": "{'dataset': 'wn18rr', 'gpu': '1', 'seed': '0', 'gcn_drop': '0.5'}", "instruction": "I am in need of your expertise to guide me through the process of utilizing the wn18rr dataset for training a cutting-edge compGCN Model. I specifically require the usage of gpu 1, seed 0, and a gcn_drop value of 0.5. Kindly assist me in crafting the code necessary to accomplish this task seamlessly.", "oracle": "How to run\nFirst to get the data, one can run\n\nsh get_fb15k-237.sh\nsh get_wn18rr.sh\nThen for FB15k-237, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data FB15k-237\nFor WN18RR, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data wn18rr", "type": "Bash Script", "id": 25, "prefix_code": "sh wn18rr.sh", "output": "python main.py --score_func conve --opn ccorr --data wn18rr --gpu 1 --seed 0 --gcn_drop 0.5"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 21, "path": "./examples/pytorch/bgrl", "arguments": "{'dataset': 'wiki_cs', 'data_seed': '94050'}", "instruction": "I have an intriguing dataset named wiki_cs, and I am eager to embark on a grand machine learning journey by training a remarkable BGRL Model. This endeavor requires the immense power of gpu 6, as well as the data_seed 94050. I beseech your assistance in crafting the code required to accomplish this remarkable feat.", "oracle": "Instructions for experiments\nTransductive task\n# Coauthor CS\npython main.py --dataset coauthor_cs --graph_encoder_layer 512 256 --drop_edge_p 0.3 0.2 --feat_mask_p 0.3 0.4\n\n# Coauthor Physics\npython main.py --dataset coauthor_physics --graph_encoder_layer 256 128 --drop_edge_p 0.4 0.1 --feat_mask_p 0.1 0.4\n\n# WikiCS\npython main.py --dataset wiki_cs --graph_encoder_layer 512 256 --drop_edge_p 0.2 0.3 --feat_mask_p 0.2 0.1 --lr 5e-4\n\n# Amazon Photos\npython main.py --dataset amazon_photos --graph_encoder_layer 256 128 --drop_edge_p 0.4 0.1 --feat_mask_p 0.1 0.2 --lr 1e-4\n\n# Amazon Computers\npython main.py --dataset amazon_computers --graph_encoder_layer 256 128 --drop_edge_p 0.5 0.4 --feat_mask_p 0.2 0.1 --lr 5e-4\n", "type": "Bash Script", "id": 26, "prefix_code": "pip install dgl==0.8.3\npip install numpy==1.21.2\n", "output": "python main.py --dataset wiki_cs --data_seed 94050"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 22, "path": "./examples/pytorch/bgrl", "arguments": "{'dataset': 'coauthor_cs', 'graph_encoder_layer': '3', 'drop_edge_p': '0 0.5', 'feat_mask_p': '0.5 0.8', 'data_seed': '94050', 'weights_dir': '../weights'}", "instruction": "To begin, I am eager to embark on a data-driven journey utilizing the coauthor_cs dataset. My ultimate goal is to train a groundbreaking BGRL Model, equipped with a dynamic graph_encoder_layer set at 3. However, I must not forget to consider crucial parameters such as drop_edge_p, which should range between 0 to 0.5, and feat_mask_p, which should ideally be set between 0.5 to 0.8. Additionally, it would be prudent to set the data_seed at 94050 for optimal reproducibility. Lastly, I kindly request your assistance in crafting the code that aligns with my specifications, and the desired weights directory for this endeavor is \"../weights\".", "oracle": "Instructions for experiments\nTransductive task\n# Coauthor CS\npython main.py --dataset coauthor_cs --graph_encoder_layer 512 256 --drop_edge_p 0.3 0.2 --feat_mask_p 0.3 0.4\n\n# Coauthor Physics\npython main.py --dataset coauthor_physics --graph_encoder_layer 256 128 --drop_edge_p 0.4 0.1 --feat_mask_p 0.1 0.4\n\n# WikiCS\npython main.py --dataset wiki_cs --graph_encoder_layer 512 256 --drop_edge_p 0.2 0.3 --feat_mask_p 0.2 0.1 --lr 5e-4\n\n# Amazon Photos\npython main.py --dataset amazon_photos --graph_encoder_layer 256 128 --drop_edge_p 0.4 0.1 --feat_mask_p 0.1 0.2 --lr 1e-4\n\n# Amazon Computers\npython main.py --dataset amazon_computers --graph_encoder_layer 256 128 --drop_edge_p 0.5 0.4 --feat_mask_p 0.2 0.1 --lr 5e-4\n", "type": "Bash Script", "id": 27, "prefix_code": "pip install dgl==0.8.3\npip install numpy==1.21.2\n", "output": "python main.py --dataset coauthor_cs --graph_encoder_layer 3 --drop_edge_p 0 0.5 --feat_mask_p 0.5 0.8 --data_seed 94050 --weights_dir ../weights"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 23, "path": "./examples/pytorch/gat", "arguments": "{'dataset': 'pubmed', 'argument': 'train'}", "instruction": "The quest that lies before me is to embark on the utilization of the esteemed pubmed dataset, which shall serve as the pristine foundation for my GAT (Graph Attention Network) training endeavor. In this fervent pursuit, I implore your assistance in scripting the code that shall pave the path to triumph. Will you join forces with me on this noble quest?", "oracle": "NOTE: train.py is deprecated and please check the new version in //examples/core/gat/train.py.\n\nRun with the following for multiclass node classification (available datasets: \"cora\", \"citeseer\", \"pubmed\")\n\npython3 train.py --dataset cora\nRun with the following for multilabel classification with PPI dataset\n\npython3 train_ppi.py\nNOTE: Users may occasionally run into low accuracy issue (e.g., test accuracy < 0.8) due to overfitting. This can be resolved by adding Early Stopping or reducing maximum number of training epochs.", "type": "Bash Script", "id": 28, "prefix_code": "", "output": "python3 train.py --dataset pubmed"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 24, "path": "./examples/pytorch/caregnn", "arguments": "{'dataset': 'amazon', 'lr': '0.005', 'weight_decay': '0.001'}", "instruction": "I have a marvelous opportunity to dive into the realm of machine learning by utilizing the mighty Amazon dataset. My plan is to train a cutting-edge Care-gnn Model, armed with the powerful learning rate of 0.005 and a weight decay of 0.001. With your invaluable expertise, could you kindly assist me in crafting the exquisite code necessary for this endeavor?", "oracle": "How to run\nTo run the full graph version and use early stopping, in the care-gnn folder, run\n\npython main.py --early-stop\nIf want to use a GPU, run\n\npython main.py --gpu 0\nTo train on Yelp dataset instead of Amazon, run\n\npython main.py --dataset yelp\nTo run the sampling version, run\n\npython main_sampling.py", "type": "Bash Script", "id": 29, "prefix_code": "pip install dgl==0.7.1\npip install scikit-learn==0.23.2", "output": "python main.py --dataset amazon --lr 0.005 --weight_decay 0.001"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 25, "path": "./examples/pytorch/caregnn", "arguments": "{'dataset': 'amazon', 'gpu': '1', 'step_size': '0.01'}", "instruction": "I have a specific requirement where I need to utilize the dataset named \"amazon\" for training a cutting-edge Care-gnn Model. However, to accelerate the training process and ensure maximum efficiency, I highly recommend utilizing the powerful GPU 7 for this task. Additionally, please note that the optimal step size to achieve the desired results is 0.01. Can you lend me your expertise by crafting the necessary code to fulfill this intricate request?", "oracle": "How to run\nTo run the full graph version and use early stopping, in the care-gnn folder, run\n\npython main.py --early-stop\nIf want to use a GPU, run\n\npython main.py --gpu 0\nTo train on Yelp dataset instead of Amazon, run\n\npython main.py --dataset yelp\nTo run the sampling version, run\n\npython main_sampling.py", "type": "Bash Script", "id": 30, "prefix_code": "pip install dgl==0.7.1\npip install scikit-learn==0.23.2", "output": "python main.py --dataset amazon --gpu 1 --step_size 0.01"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 1, "path": "./", "arguments": "{'model': './wwm_cased_L-24_H-1024_A-16', 'train_batch_size': 32, 'max_seq_length': 512, 'max_predictions_per_seq': 20, 'num_train_steps': 300000, 'num_warmup_steps': 2000, 'learning_rate': '0.00001'}", "instruction": "I am embarking on a mighty endeavor, one that involves the pre-training of the illustrious wwm_cased_L-24_H-1024_A-16 model. In order to accomplish this monumental task successfully, I must make some crucial configurations. Firstly, I have determined that setting the maximum sequence length to 512 and the maximum predictions per sequence to 20 will prove beneficial. Furthermore, I intend to train the model optimally by employing a batch size of 32 throughout the rigorous training journey, spanning a total of 300,000 steps. In addition, it is of utmost importance to establish a warm-up period of 300,000 steps and set the learning rate at 0.00001. I implore your invaluable assistance in formulating the code necessary to commence this exhilarating mission.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 31, "prefix_code": "export BERT_BASE_DIR=./model/wwm_cased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_cased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_cased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=2000   --learning_rate=0.00001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 2, "path": "./", "arguments": "{'model': './model/cased_L-12_H-768_A-12', 'max_seq_length': 128, 'max_predictions_per_seq': 20, 'num_train_steps': 1000, 'masked_lm_prob': 0.15}", "instruction": "My ultimate goal lies in the preparation of pretraining data for a specific model, namely the './model/cased_L-12_H-768_A-12'. To accomplish this, it is crucial to set the maximum sequence length at 128. Additionally, the model should undergo a rigorous training regimen consisting of 1000 steps. During this process, the maximum predictions per sequence should be capped at 20, while maintaining a masked language modeling probability of 0.15. Could you graciously lend your expertise in crafting the necessary code to bring this vision to fruition?", "oracle": "Here's how to run the data generation. The input is a plain text file, with one\nsentence per line. (It is important that these be actual sentences for the \"next\nsentence prediction\" task). Documents are delimited by empty lines. The output\nis a set of `tf.train.Example`s serialized into `TFRecord` file format.\n\nYou can perform sentence segmentation with an off-the-shelf NLP toolkit such as\n[spaCy](https://spacy.io/). The `create_pretraining_data.py` script will\nconcatenate segments until they reach the maximum sequence length to minimize\ncomputational waste from padding (see the script for more details). However, you\nmay want to intentionally add a slight amount of noise to your input data (e.g.,\nrandomly truncate 2% of input segments) to make it more robust to non-sentential\ninput during fine-tuning.\n\nThis script stores all of the examples for the entire input file in memory, so\nfor large data files you should shard the input file and call the script\nmultiple times. (You can pass in a file glob to `run_pretraining.py`, e.g.,\n`tf_examples.tf_record*`.)\n\nThe `max_predictions_per_seq` is the maximum number of masked LM predictions per\nsequence. You should set this to around `max_seq_length` * `masked_lm_prob` (the\nscript doesn't do that automatically because the exact value needs to be passed\nto both scripts).\n\n```shell\npython create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=$BERT_BASE_DIR/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --masked_lm_prob=0.15   --random_seed=12345   --dupe_factor=5\n```", "type": "Bash Script", "id": 32, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12", "output": "python create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=./model/cased_L-12_H-768_A-12/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=1000    --masked_lm_prob=0.15"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 3, "path": "./", "arguments": "{'model': './model/cased_L-12_H-768_A-12', 'task': 'MRPC', 'train batch size': '16'}", "instruction": "Ahoy! I find myself embarking on an exciting quest that involves harnessing the power of the illustrious './model/cased_L-12_H-768_A-12' pre-trained model. My noble mission is to undertake finetuning specifically for the MRPC task. To enhance the training process, it is vital to configure the train batch size to a magnificent 16. Might you be able to assist me by crafting the necessary code to achieve this goal?", "oracle": "### Sentence (and sentence-pair) classification tasks\n\n    Before running this example you must download the\n    [GLUE data](https://gluebenchmark.com/tasks) by running\n    [this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\n    and unpack it to some directory `$GLUE_DIR`. Next, download the `BERT-Base`\n    checkpoint and unzip it to some directory `$BERT_BASE_DIR`.\n\n    This example code fine-tunes `BERT-Base` on the Microsoft Research Paraphrase\n    Corpus (MRPC) corpus, which only contains 3,600 examples and can fine-tune in a\n    few minutes on most GPUs.\n\n    ```shell\n    export BERT_BASE_DIR=/path/to/bert/uncased_L-12_H-768_A-12\n    export GLUE_DIR=/path/to/glue\n\n    python run_classifier.py     --task_name=MRPC     --do_train=true     --do_eval=true     --data_dir=$GLUE_DIR/MRPC     --vocab_file=$BERT_BASE_DIR/vocab.txt     --bert_config_file=$BERT_BASE_DIR/bert_config.json     --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt     --max_seq_length=128     --train_batch_size=32     --learning_rate=2e-5     --num_train_epochs=3.0     --output_dir=/tmp/mrpc_output/\n    ```\n    ", "type": "Bash Script", "id": 33, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12\nexport GLUE_DIR=./data/glue_data", "output": "python run_classifier.py   --task_name=MRPC   --do_train=true   --do_eval=true   --data_dir=$GLUE_DIR/MRPC   --vocab_file=./model/cased_L-12_H-768_A-12/vocab.txt   --bert_config_file=./model/cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/cased_L-12_H-768_A-12/bert_model.ckpt   --max_seq_length=128  --train_batch_size  16"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 4, "path": "./", "arguments": "{'model': './multi_cased_L-12_H-768_A-12', 'max_seq_length': 512, 'max_predictions_per_seq': 30, 'num_train_steps': 1000, 'masked_lm_prob': 0.15}", "instruction": "With an indomitable spirit and unwavering determination in my heart, I embark upon the noble task of meticulously preparing the pretraining data that will serve as the lifeblood for our cherished model, the multi_cased_L-12_H-768_A-12. It is my ardent wish to achieve this feat by orchestrating a symphony of parameters, wherein the maximum sequence length shall be meticulously fine-tuned to a value of 512. Moreover, our model's resilience shall be tested through 1000 rigorous training steps, while its ingenuity shall be measured by allowing it to unleash a maximum of 30 predictions per sequence. Finally, I humbly beseech your wise counsel in ascertaining the masked language modeling probability, gracefully setting it at a noble value of 0.15. Therefore, I implore you, esteemed coding virtuoso, to bestow upon me the gift of your profound expertise in translating this vision into a code as extraordinary as the task itself.", "oracle": "Here's how to run the data generation. The input is a plain text file, with one\nsentence per line. (It is important that these be actual sentences for the \"next\nsentence prediction\" task). Documents are delimited by empty lines. The output\nis a set of `tf.train.Example`s serialized into `TFRecord` file format.\n\nYou can perform sentence segmentation with an off-the-shelf NLP toolkit such as\n[spaCy](https://spacy.io/). The `create_pretraining_data.py` script will\nconcatenate segments until they reach the maximum sequence length to minimize\ncomputational waste from padding (see the script for more details). However, you\nmay want to intentionally add a slight amount of noise to your input data (e.g.,\nrandomly truncate 2% of input segments) to make it more robust to non-sentential\ninput during fine-tuning.\n\nThis script stores all of the examples for the entire input file in memory, so\nfor large data files you should shard the input file and call the script\nmultiple times. (You can pass in a file glob to `run_pretraining.py`, e.g.,\n`tf_examples.tf_record*`.)\n\nThe `max_predictions_per_seq` is the maximum number of masked LM predictions per\nsequence. You should set this to around `max_seq_length` * `masked_lm_prob` (the\nscript doesn't do that automatically because the exact value needs to be passed\nto both scripts).\n\n```shell\npython create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=$BERT_BASE_DIR/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --masked_lm_prob=0.15   --random_seed=12345   --dupe_factor=5\n```", "type": "Bash Script", "id": 34, "prefix_code": "export BERT_BASE_DIR=./model/multi_cased_L-12_H-768_A-12", "output": "python create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=./model/multi_cased_L-12_H-768_A-12/vocab.txt   --do_lower_case=True   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=1000    --masked_lm_prob=0.15"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 5, "path": "./", "arguments": "{'model': './model/uncased_L-12_H-768_A-12', 'max_seq_length': 128, 'max_predictions_per_seq': 30, 'num_train_steps': 2000, 'masked_lm_prob': 0.15}", "instruction": "Behold! A noble quest lies before me as I embark on the journey to meticulously prepare the pretraining data for the revered ./model/uncased_L-12_H-768_A-12. To conquer this arduous task, my heart yearns for a code that will bestow upon me the power to set a maximum sequence length of 128 and subject the majestic model to an epic feat of endurance spanning 2000 grueling training steps. Furthermore, I beseech you to guide me in restricting the maximum predictions per sequence to a mere 30, while bestowing upon the masked lm a noble probability of 0.15. In this noble pursuit, I am the humble apprentice seeking your esteemed mentorship and guidance in forging the sacred script that shall bring my vision to life.", "oracle": "Here's how to run the data generation. The input is a plain text file, with one\nsentence per line. (It is important that these be actual sentences for the \"next\nsentence prediction\" task). Documents are delimited by empty lines. The output\nis a set of `tf.train.Example`s serialized into `TFRecord` file format.\n\nYou can perform sentence segmentation with an off-the-shelf NLP toolkit such as\n[spaCy](https://spacy.io/). The `create_pretraining_data.py` script will\nconcatenate segments until they reach the maximum sequence length to minimize\ncomputational waste from padding (see the script for more details). However, you\nmay want to intentionally add a slight amount of noise to your input data (e.g.,\nrandomly truncate 2% of input segments) to make it more robust to non-sentential\ninput during fine-tuning.\n\nThis script stores all of the examples for the entire input file in memory, so\nfor large data files you should shard the input file and call the script\nmultiple times. (You can pass in a file glob to `run_pretraining.py`, e.g.,\n`tf_examples.tf_record*`.)\n\nThe `max_predictions_per_seq` is the maximum number of masked LM predictions per\nsequence. You should set this to around `max_seq_length` * `masked_lm_prob` (the\nscript doesn't do that automatically because the exact value needs to be passed\nto both scripts).\n\n```shell\npython create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=$BERT_BASE_DIR/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --masked_lm_prob=0.15   --random_seed=12345   --dupe_factor=5\n```", "type": "Bash Script", "id": 35, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12", "output": "python create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=./model/uncased_L-12_H-768_A-12/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=30   --num_train_steps=2000    --masked_lm_prob=0.15"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 7, "path": "./", "arguments": "{'model': './model/uncased_L-24_H-1024_A-16', 'train_batch_size': 32, 'max_seq_length': 512, 'max_predictions_per_seq': 30, 'num_train_steps': 10000, 'num_warmup_steps': 1000, 'learning_rate': '0.0001'}", "instruction": "Behold, a formidable quest awaits - the pre-training of the unparalleled uncased_L-24_H-1024_A-16 model. Our path to victory lies in configuring the maximum sequence length to a mighty 512, with a pledge to uphold the limit of 30 predictions per sequence. Battling through the treacherous terrain of 10000 steps, we shall march forward, with a stalwart battalion of 32 batch size by our side. But fear not, for we shall brace ourselves with 10000 warmup steps, as we navigate the perilous sea of learning, with a steadfast learning rate of 0.0001. I humbly beseech your assistance, noble comrade, to conjure the code necessary to conquer this heroic endeavor.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 37, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=10000   --num_warmup_steps=1000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 9, "path": "./", "arguments": "{'model': './model/uncased_L-24_H-1024_A-16', 'max_seq_length': 128, 'max_predictions_per_seq': 20, 'num_train_steps': 2000, 'masked_lm_prob': 0.15}", "instruction": "I have set my sights on preparing the pretraining data for the esteemed uncased_L-24_H-1024_A-16 model, which resides within the sacred confines of the \"./model/\" directory. My fervent desire is to establish the maximum sequence length at a humble 128 and subject the model to an arduous training journey spanning a grand total of 2000 steps. During this treacherous voyage, I implore you to be my guiding light as we navigate the perilous terrain of setting the maximum predictions per sequence at a mere 20 and a masked language model probability of 0.15. Will you graciously offer your expertise and aid me in crafting the code necessary for this monumental undertaking?", "oracle": "Here's how to run the data generation. The input is a plain text file, with one\nsentence per line. (It is important that these be actual sentences for the \"next\nsentence prediction\" task). Documents are delimited by empty lines. The output\nis a set of `tf.train.Example`s serialized into `TFRecord` file format.\n\nYou can perform sentence segmentation with an off-the-shelf NLP toolkit such as\n[spaCy](https://spacy.io/). The `create_pretraining_data.py` script will\nconcatenate segments until they reach the maximum sequence length to minimize\ncomputational waste from padding (see the script for more details). However, you\nmay want to intentionally add a slight amount of noise to your input data (e.g.,\nrandomly truncate 2% of input segments) to make it more robust to non-sentential\ninput during fine-tuning.\n\nThis script stores all of the examples for the entire input file in memory, so\nfor large data files you should shard the input file and call the script\nmultiple times. (You can pass in a file glob to `run_pretraining.py`, e.g.,\n`tf_examples.tf_record*`.)\n\nThe `max_predictions_per_seq` is the maximum number of masked LM predictions per\nsequence. You should set this to around `max_seq_length` * `masked_lm_prob` (the\nscript doesn't do that automatically because the exact value needs to be passed\nto both scripts).\n\n```shell\npython create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=$BERT_BASE_DIR/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --masked_lm_prob=0.15   --random_seed=12345   --dupe_factor=5\n```", "type": "Bash Script", "id": 39, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-24_H-1024_A-16", "output": "python create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=./model/uncased_L-24_H-1024_A-16/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=2000    --masked_lm_prob=0.15"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 10, "path": "./", "arguments": "{'model': './model/uncased_L-12_H-768_A-12', 'version': '2.0', 'thresh': -1.0, 'output_dir': './'}", "instruction": "Ladies and gentlemen, gather 'round! Allow me to present to you a fascinating proposition. I have a burning desire to employ the almighty power of the uncased_L-12_H-768_A-12 model, which can be found in the majestic directory labeled './model/'. My ultimate goal is to predict and conquer the formidable SQUAD2.0 task, and I have decided to set the null score diff threshold as -1.0 to ensure the highest level of accuracy. To seal the deal, I plan to establish the output directory as '.' (yes, just a single dot). In my quest for greatness, I humbly implore your help in crafting the necessary code. Will you join me on this epic journey?", "oracle": "### SQuAD 2.0\n\n        This model is also implemented and documented in `run_squad.py`.\n\n        To run on SQuAD 2.0, you will first need to download the dataset. The necessary\n        files can be found here:\n\n        *   [train-v2.0.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v2.0.json)\n        *   [dev-v2.0.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/dev-v2.0.json)\n        *   [evaluate-v2.0.py](https://worksheets.codalab.org/rest/bundles/0x6b567e1cf2e041ec80d7098f031c5c9e/contents/blob/)\n\n        Download these to some directory `$SQUAD_DIR`.\n\n        On Cloud TPU you can run with BERT-Large as follows:\n\n        ```shell\n        python run_squad.py         --vocab_file=$BERT_LARGE_DIR/vocab.txt         --bert_config_file=$BERT_LARGE_DIR/bert_config.json         --init_checkpoint=$BERT_LARGE_DIR/bert_model.ckpt         --do_train=True         --train_file=$SQUAD_DIR/train-v2.0.json         --do_predict=True         --predict_file=$SQUAD_DIR/dev-v2.0.json         --train_batch_size=24         --learning_rate=3e-5         --num_train_epochs=2.0         --max_seq_length=384         --doc_stride=128         --output_dir=gs://some_bucket/squad_large/         --use_tpu=True         --tpu_name=$TPU_NAME         --version_2_with_negative=True\n        ```", "type": "Bash Script", "id": 40, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12\nexport SQUAD_DIR=./data/squad/", "output": "python run_squad.py   --vocab_file=./model/uncased_L-12_H-768_A-12/vocab.txt   --bert_config_file=./model/uncased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/uncased_L-12_H-768_A-12/bert_model.ckpt   --do_train=False   --do_predict=True   --predict_file=$SQUAD_DIR/dev-v2.0.json   --max_seq_length=384   --doc_stride=128   --null_score_diff_threshold=-1.0  --version_2_with_negative=True  --output_dir ./"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 11, "path": "./", "arguments": "{'model': './model/cased_L-12_H-768_A-12', 'train_batch_size': 32, 'max_seq_length': 512, 'max_predictions_per_seq': 20, 'num_train_steps': 300000, 'learning_rate': '0.0001'}", "instruction": "I am embarking on an ambitious mission to pre-train the powerful ./model/cased_L-12_H-768_A-12. To ensure optimal results, I intend to set the maximum sequence length to 512 and the maximum predictions per sequence to 20. In order to train this remarkable model, I require your expertise to design a code that utilizes a batch size of 32 for a staggering 300,000 training steps. Additionally, I will need your guidance to implement a warm-up phase of 300,000 steps and maintain a learning rate of 0.0001. Will you join me on this epic coding adventure?", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 41, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/cased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=1000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 12, "path": "./", "arguments": "{'model': './multi_cased_L-12_H-768_A-12', 'train_batch_size': 64, 'max_seq_length': 512, 'max_predictions_per_seq': 20, 'num_train_steps': 10000, 'num_warmup_steps': 1000, 'learning_rate': '0.00001'}", "instruction": "In order to fulfill my objective of pre-training the multi_cased_L-12_H-768_A-12 model, I am in need of assistance with configuring various parameters. Specifically, I plan to set the maximum sequence length to 512 and the maximum predictions per sequence to 20. Furthermore, I aim to train the model using a batch size of 64, completing 10000 training steps, with an equal number of warmup steps. To facilitate this process, I intend to utilize a learning rate of 0.00001. Your invaluable input is highly sought after in writing the code essential to accomplishing this mission.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 42, "prefix_code": "export BERT_BASE_DIR=./model/multi_cased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/multi_cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/multi_cased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=64   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=1000   --learning_rate=0.00001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 13, "path": "./", "arguments": "{'model': './model/cased_L-24_H-1024_A-16', 'train_batch_size': 64, 'max_seq_length': 512, 'max_predictions_per_seq': 30, 'num_train_steps': 10000, 'num_warmup_steps': 1000, 'learning_rate': '0.0001'}", "instruction": "In pursuit of greatness, it has come to my attention that it is crucial to pre-train the esteemed ./model/cased_L-24_H-1024_A-16. To achieve this feat, I have honed a cunning strategy which involves setting the maximum sequence length to a commendable 512 and allowing a generous 30 predictions per sequence. To train this model, I shall assemble a formidable army of 64 batches, marching them through an arduous training regimen spanning 10000 grueling steps. However, realizing the significance of endurance, I propose a warming-up period of 10000 steps, all while adhering to a noble learning rate of 0.0001. My esteemed comrade, I beseech thee to join me on this quest and forge the code that shall seal our success.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 43, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/cased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/cased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=64   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=10000   --num_warmup_steps=1000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 15, "path": "./", "arguments": "{'model': './model/wwm_uncased_L-24_H-1024_A-16', 'train_batch_size': 32, 'max_seq_length': 512, 'max_predictions_per_seq': 20, 'num_train_steps': 10000, 'learning_rate': '0.0005'}", "instruction": "Hear ye, noble savant of programming! I beseech thee to lend me thy wisdom and aid in the endeavor to pre-train the illustrious ./model/wwm_uncased_L-24_H-1024_A-16. To bring forth a masterpiece, the parameters must be perfectly attuned. The maximum sequence length shall be set at 512, and the maximum predictions per sequence shall not exceed 20. In the hallowed halls of training, I implore thee to compose a code that employs a batch size of 32 for a mighty 10,000 steps, with a warm-up of equal magnitude. The crown jewel of this code shall be the learning rate, set reverently at 0.0005. Thy assistance in this noble quest shall be emblazoned in the annals of computer science.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 45, "prefix_code": "export BERT_BASE_DIR=./model/wwm_uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=2000   --learning_rate=0.0005"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 16, "path": "./", "arguments": "{'model': './uncased_L-24_H-1024_A-16', 'train_batch_size': 64, 'max_seq_length': 256, 'max_predictions_per_seq': 30, 'num_train_steps': 300000, 'learning_rate': '0.00001'}", "instruction": "Here's the ambitious plan - I aim to pre-train the awe-inspiring uncased_L-24_H-1024_A-16 model. To accomplish this feat, I envision configuring the maximum sequence length to 256, employing a cap of 30 maximum predictions per sequence. With an enigmatic batch size of 64, I shall embark on an arduous journey of 300,000 training steps, while ensuring an equal number of warmup steps. In this endeavor, I humbly seek your assistance in formulating the code required to bring this ambitious mission to fruition. The desired learning rate of 0.00001 shall guide us on this intrepid path. Together, let us embark on this coding odyssey, fueled by determination and a thirst for knowledge.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 46, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=64   --max_seq_length=256   --max_predictions_per_seq=30   --num_train_steps=300000   --num_warmup_steps=1000   --learning_rate=0.00001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 17, "path": "./", "arguments": "{'model': './model/multi_cased_L-12_H-768_A-12', 'train_batch_size': 64, 'max_seq_length': 256, 'max_predictions_per_seq': 20, 'num_train_steps': 10000, 'learning_rate': '0.0005'}", "instruction": "In order to embark on the mission of pre-training the magnificent multi_cased_L-12_H-768_A-12 model, precise configurations must be made. It is crucial to configure the maximum sequence length to be no greater than 256 and limit the number of predictions per sequence to a maximum of 20. Additionally, the training process should be carried out using a batch size of 64. This training should be conducted over a course of 10000 steps, with an initial phase of 10000 warm-up steps. It is important to note that the learning rate should be set at 0.0005. Your exceptional coding skills are kindly requested to help materialize this ambitious endeavor.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 47, "prefix_code": "export BERT_BASE_DIR=./model/multi_cased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/multi_cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/multi_cased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=64   --max_seq_length=256   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=2000   --learning_rate=0.0005"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 18, "path": "./", "arguments": "{'model': './model/wwm_cased_L-24_H-1024_A-16', 'max_seq_length': 256, 'max_predictions_per_seq': 30, 'num_train_steps': 300000, 'learning_rate': '0.00001'}", "instruction": "With the noble objective of embarking upon the pre-training voyage of the revered ./model/wwm_cased_L-24_H-1024_A-16, it is my solemn intention to configure the maximum sequence length at a majestic 256, coupled with a befitting maximum predictions per sequence of 30. Upon this foundation, I yearn for your invaluable assistance in training the model through the arduous journey of 300,000 steps, with each step representing a testament to our unwavering dedication. As we navigate this treacherous path, a warm-up phase consisting of 300,000 steps shall serve as our guiding light. Through the cultivation of an enlightened learning rate of 0.00001, we shall lay the groundwork for a future brimming with astonishing discoveries. I humbly implore you to join me on this sacred quest, lending your wisdom in the form of code that shall elevate us to heights previously unfathomable.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 48, "prefix_code": "export BERT_BASE_DIR=./model/wwm_cased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_cased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_cased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=64   --max_seq_length=256   --max_predictions_per_seq=30   --num_train_steps=300000   --num_warmup_steps=1000   --learning_rate=0.00001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 19, "path": "./", "arguments": "{'model': './uncased_L-12_H-768_A-12', 'train_batch_size': 32, 'max_seq_length': 256, 'max_predictions_per_seq': 20, 'num_train_steps': 300000, 'learning_rate': '0.0001'}", "instruction": "My current endeavor revolves around the pre-training of the uncased_L-12_H-768_A-12 model, which necessitates several intricate configurations. Specifically, I intend to set the maximum sequence length to 256 and limit the maximum predictions per sequence to a modest 20. Furthermore, the model must undergo training for an extensive period of 300,000 steps, with an additional 300,000 steps dedicated to warmup. To ensure optimal results, it is crucial to establish a batch size of 32, all while adhering to a precise learning rate of 0.0001. Thus, I kindly seek your valuable assistance in crafting the intricate code to achieve this formidable mission.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 49, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/uncased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=256   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=2000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 22, "path": "./", "arguments": "{'model': './model/cased_L-12_H-768_A-12', 'max_seq_length': 128, 'max_predictions_per_seq': 30, 'num_train_steps': 2000, 'masked_lm_prob': 0.1}", "instruction": "I have set my sights on a grand endeavor - the preparation of the pretraining data for the revered ./model/cased_L-12_H-768_A-12. With great care and precision, I plan to align the stars by configuring the model to endure 2000 grueling training steps, all while keeping the maximum sequence length restricted to a steadfast 128. Furthermore, I seek to achieve excellence by limiting the predictions per sequence to a hard cap of 30, and implementing a masked language model probability of 0.1. In my quest for greatness, I humbly request your guidance and wisdom in the pursuit of crafting the code required for this noble undertaking.", "oracle": "Here's how to run the data generation. The input is a plain text file, with one\nsentence per line. (It is important that these be actual sentences for the \"next\nsentence prediction\" task). Documents are delimited by empty lines. The output\nis a set of `tf.train.Example`s serialized into `TFRecord` file format.\n\nYou can perform sentence segmentation with an off-the-shelf NLP toolkit such as\n[spaCy](https://spacy.io/). The `create_pretraining_data.py` script will\nconcatenate segments until they reach the maximum sequence length to minimize\ncomputational waste from padding (see the script for more details). However, you\nmay want to intentionally add a slight amount of noise to your input data (e.g.,\nrandomly truncate 2% of input segments) to make it more robust to non-sentential\ninput during fine-tuning.\n\nThis script stores all of the examples for the entire input file in memory, so\nfor large data files you should shard the input file and call the script\nmultiple times. (You can pass in a file glob to `run_pretraining.py`, e.g.,\n`tf_examples.tf_record*`.)\n\nThe `max_predictions_per_seq` is the maximum number of masked LM predictions per\nsequence. You should set this to around `max_seq_length` * `masked_lm_prob` (the\nscript doesn't do that automatically because the exact value needs to be passed\nto both scripts).\n\n```shell\npython create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=$BERT_BASE_DIR/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=20   --masked_lm_prob=0.15   --random_seed=12345   --dupe_factor=5\n```", "type": "Bash Script", "id": 52, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12", "output": "python create_pretraining_data.py   --input_file=./sample_text.txt   --output_file=/tmp/tf_examples.tfrecord   --vocab_file=./model/cased_L-12_H-768_A-12/vocab.txt   --do_lower_case=True   --max_seq_length=128   --max_predictions_per_seq=30   --num_train_steps=2000    --masked_lm_prob=0.1"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 23, "path": "./", "arguments": "{'model': './model/uncased_L-12_H-768_A-12', 'train_batch_size': 32, 'max_seq_length': 512, 'max_predictions_per_seq': 30, 'num_train_steps': 300000, 'learning_rate': '0.0001'}", "instruction": "In pursuit of a monumental feat, my aim is to unleash the full potential of the revered uncased_L-12_H-768_A-12 model resting comfortably within the sacred grounds of the ./model/ directory. With meticulous attention to detail, I intend to calibrate the maximum sequence length to an impressive 512, all while ensuring a delightful maximum of 30 predictions per sequence. To usher in the era of transformation, I have laid out a well-thought-out blueprint for training the model, employing a robust batch size of 32 over the course of a staggering 300,000 steps. An equal number of warmup steps shall pave the way to mastery, guided by the venerable learning rate of 0.0001. Aligning myself with the stars of success, I humbly seek your expertise in scripting the code that shall bring this vision to fruition.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 53, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/uncased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=300000   --num_warmup_steps=2000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 24, "path": "./", "arguments": "{'model': './model/wwm_cased_L-24_H-1024_A-16', 'version': '1.1', 'thresh': -5.0}", "instruction": "When it comes to predicting on the SQUAD1.1 task using the powerful ./model/wwm_cased_L-24_H-1024_A-16 model, I've set the null score diff threshold at -5.0. It would be greatly appreciated if you could lend a helping hand in crafting the code required to tackle this challenge. Can I count on your expertise?", "oracle": "### SQuAD 1.1\n\n        The Stanford Question Answering Dataset (SQuAD) is a popular question answering\n        benchmark dataset. BERT (at the time of the release) obtains state-of-the-art\n        results on SQuAD with almost no task-specific network architecture modifications\n        or data augmentation. However, it does require semi-complex data pre-processing\n        and post-processing to deal with (a) the variable-length nature of SQuAD context\n        paragraphs, and (b) the character-level answer annotations which are used for\n        SQuAD training. This processing is implemented and documented in `run_squad.py`.\n\n        To run on SQuAD, you will first need to download the dataset. The\n        [SQuAD website](https://rajpurkar.github.io/SQuAD-explorer/) does not seem to\n        link to the v1.1 datasets any longer, but the necessary files can be found here:\n\n        *   [train-v1.1.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v1.1.json)\n        *   [dev-v1.1.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/dev-v1.1.json)\n        *   [evaluate-v1.1.py](https://github.com/allenai/bi-att-flow/blob/master/squad/evaluate-v1.1.py)\n\n        Download these to some directory `$SQUAD_DIR`.\n\n        The state-of-the-art SQuAD results from the paper currently cannot be reproduced\n        on a 12GB-16GB GPU due to memory constraints (in fact, even batch size 1 does\n        not seem to fit on a 12GB GPU using `BERT-Large`). However, a reasonably strong\n        `BERT-Base` model can be trained on the GPU with these hyperparameters:\n\n        ```shell\n        python run_squad.py         --vocab_file=$BERT_BASE_DIR/vocab.txt         --bert_config_file=$BERT_BASE_DIR/bert_config.json         --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt         --do_train=True         --train_file=$SQUAD_DIR/train-v1.1.json         --do_predict=True         --predict_file=$SQUAD_DIR/dev-v1.1.json         --train_batch_size=12         --learning_rate=3e-5         --num_train_epochs=2.0         --max_seq_length=384         --doc_stride=128         --output_dir=/tmp/squad_base/\n        ```", "type": "Bash Script", "id": 54, "prefix_code": "export BERT_BASE_DIR=./model/wwm_cased_L-24_H-1024_A-16\nexport SQUAD_DIR=./data/squad/", "output": "python run_squad.py   --vocab_file=./model/wwm_cased_L-24_H-1024_A-16/vocab.txt   --bert_config_file=./model/wwm_cased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_cased_L-24_H-1024_A-16/bert_model.ckpt   --do_train=False   --do_predict=True   --predict_file=$SQUAD_DIR/dev-v1.1.json   --max_seq_length=384   --doc_stride=128   --null_score_diff_threshold=-5.0 "}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 26, "path": "./", "arguments": "{'model': './model/wwm_uncased_L-24_H-1024_A-16', 'train_batch_size': 64, 'max_seq_length': 512, 'max_predictions_per_seq': 20, 'num_train_steps': 10000, 'learning_rate': '0.0001'}", "instruction": "The quest to pre-train the revered ./model/wwm_uncased_L-24_H-1024_A-16 beckons, and I am determined to triumph in this endeavor. My plan is to configure the maximum sequence length to a commendable 512, and limit the predictions per sequence to an admirable tally of 20. With unwavering dedication, I shall shepherd the model through the treacherous waters of training, utilizing a batch size of 64 over the course of 10,000 grueling steps. To ensure a smooth initiation, a warm-up period of 10,000 steps shall be bestowed upon the model, guided by the illuminating beacon of a learning rate set at 0.0001. I beseech your invaluable assistance in weaving together the intricate code that shall bring this epic mission to fruition.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 56, "prefix_code": "export BERT_BASE_DIR=./model/wwm_uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=64   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=2000   --learning_rate=0.0001"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 29, "path": "./", "arguments": "{'model': './cased_L-12_H-768_A-12', 'train_batch_size': 64, 'max_seq_length': 256, 'max_predictions_per_seq': 20, 'num_train_steps': 10000, 'learning_rate': '0.0005'}", "instruction": "Our ultimate mission is to pre-train the powerful cased_L-12_H-768_A-12 model, housed within the './model/' directory. To optimize performance, we must configure the maximum sequence length to a formidable 256 and set the maximum predictions per sequence to an ambitious 20. With a jaw-dropping batch size of 64, we will embark on a training journey spanning a remarkable 10,000 steps. To ensure a smooth ascent towards success, we will warm up with 10,000 steps before reaching peak performance. And all of this will be made possible under the guiding light of a learning rate set at an impressive 0.0005. We humbly seek your expertise in crafting the code that will unlock this extraordinary feat.", "oracle": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n", "type": "Bash Script", "id": 59, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/cased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=64   --max_seq_length=256   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=2000   --learning_rate=0.0005"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 30, "path": "./", "arguments": "{'model': './model/uncased_L-24_H-1024_A-16', 'version': '2.0', 'thresh': -2.0}", "instruction": "/model/uncased_L-24_H-1024_A-16' directory. My ultimate goal is to apply this model for predictions on the challenging SQUAD2.0 task. A crucial requirement of this task is to set the null score diff threshold to -2.0. Would you kindly lend a helping hand in crafting the essential code to accomplish this?", "oracle": "### SQuAD 2.0\n\n        This model is also implemented and documented in `run_squad.py`.\n\n        To run on SQuAD 2.0, you will first need to download the dataset. The necessary\n        files can be found here:\n\n        *   [train-v2.0.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v2.0.json)\n        *   [dev-v2.0.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/dev-v2.0.json)\n        *   [evaluate-v2.0.py](https://worksheets.codalab.org/rest/bundles/0x6b567e1cf2e041ec80d7098f031c5c9e/contents/blob/)\n\n        Download these to some directory `$SQUAD_DIR`.\n\n        On Cloud TPU you can run with BERT-Large as follows:\n\n        ```shell\n        python run_squad.py         --vocab_file=$BERT_LARGE_DIR/vocab.txt         --bert_config_file=$BERT_LARGE_DIR/bert_config.json         --init_checkpoint=$BERT_LARGE_DIR/bert_model.ckpt         --do_train=True         --train_file=$SQUAD_DIR/train-v2.0.json         --do_predict=True         --predict_file=$SQUAD_DIR/dev-v2.0.json         --train_batch_size=24         --learning_rate=3e-5         --num_train_epochs=2.0         --max_seq_length=384         --doc_stride=128         --output_dir=gs://some_bucket/squad_large/         --use_tpu=True         --tpu_name=$TPU_NAME         --version_2_with_negative=True\n        ```", "type": "Bash Script", "id": 60, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-24_H-1024_A-16\nexport SQUAD_DIR=./data/squad/", "output": "python run_squad.py   --vocab_file=./model/uncased_L-24_H-1024_A-16/vocab.txt   --bert_config_file=./model/uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/uncased_L-24_H-1024_A-16/bert_model.ckpt   --do_train=False   --do_predict=True   --predict_file=$SQUAD_DIR/dev-v2.0.json   --max_seq_length=384   --doc_stride=128   --null_score_diff_threshold=-2.0  --version_2_with_negative=True "}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 1, "path": "./", "arguments": "{'model': 'esm_msa1b_t12_100M_UR50S', 'data': 'MKTVRQERLKSIVRILERSKEPV'}", "instruction": "I need assistance in writing code to utilize esm_msa1b_t12_100M_UR50S() for the ESMFold Structure Prediction task and save the result. The data sequence I have is MKTVRQERLKSIVRILERSKEPV.", "oracle": "\nAfter installing with the [esmfold] option, you can use the ESMFold structure prediction model as follows:\n\nimport torch\nimport esm\n\nmodel = esm.pretrained.esmfold_v1()\nmodel = model.eval().cuda()\n\n# Optionally, uncomment to set a chunk size for axial attention. This can help reduce memory.\n# Lower sizes will have lower memory requirements at the cost of increased speed.\n# model.set_chunk_size(128)\n\nsequence = \"MKTVRQERLKSIVRILERSKEPVSGAQLAEELSVSRQVIVQDIAYLRSLGYNIVATPRGYVLAGG\"\n# Multimer prediction can be done with chains separated by ':'\n\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\nwith open(\"result.pdb\", \"w\") as f:\n    f.write(output)\n\nimport biotite.structure.io as bsio\nstruct = bsio.load_structure(\"result.pdb\", extra_fields=[\"b_factor\"])\nprint(struct.b_factor.mean())  # this will be the pLDDT\n# 88.3\nBesides esm.pretrained.esmfold_v1() which is the best performing model we recommend using, we also provide esm.pretrained.esmfold_v0() which was used for the experiments in Lin et al. 2022.\n", "type": "Python Code", "id": 151, "prefix_code": "", "output": "\nimport torch\nimport esm\nimport biotite.structure.io as bsio\n\n# Load the ESMFold model\nmodel = esm.pretrained.esm_msa1b_t12_100M_UR50S()\nmodel = model.eval().cuda()\n\n# Set the input sequence\nsequence = \"MKTVRQERLKSIVRILERSKEPV\"\n\n# Perform structure prediction\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\n# Save the output structure to a PDB file\nwith open(\"output.pdb\", \"w\") as f:\n    f.write(output)\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 2, "path": "./", "arguments": "{'model': 'esm1v_t33_650M_UR90S_5', 'data': 'MKTVRQERLKSIVRILERSKEPV', 'output_dir': 'model_structure.pdb'}", "instruction": "I need assistance in writing code to utilize the esm1v_t33_650M_UR90S_5() function for the ESMFold Structure Prediction task. The input data sequence is MKTVRQERLKSIVRILERSKEPV, and the output should be saved as model_structure.pdb. Can you provide guidance?", "oracle": "\nAfter installing with the [esmfold] option, you can use the ESMFold structure prediction model as follows:\n\nimport torch\nimport esm\n\nmodel = esm.pretrained.esmfold_v1()\nmodel = model.eval().cuda()\n\n# Optionally, uncomment to set a chunk size for axial attention. This can help reduce memory.\n# Lower sizes will have lower memory requirements at the cost of increased speed.\n# model.set_chunk_size(128)\n\nsequence = \"MKTVRQERLKSIVRILERSKEPVSGAQLAEELSVSRQVIVQDIAYLRSLGYNIVATPRGYVLAGG\"\n# Multimer prediction can be done with chains separated by ':'\n\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\nwith open(\"result.pdb\", \"w\") as f:\n    f.write(output)\n\nimport biotite.structure.io as bsio\nstruct = bsio.load_structure(\"result.pdb\", extra_fields=[\"b_factor\"])\nprint(struct.b_factor.mean())  # this will be the pLDDT\n# 88.3\nBesides esm.pretrained.esmfold_v1() which is the best performing model we recommend using, we also provide esm.pretrained.esmfold_v0() which was used for the experiments in Lin et al. 2022.\n", "type": "Python Code", "id": 152, "prefix_code": "", "output": "\nimport torch\nimport esm\nimport biotite.structure.io as bsio\n\n# Load the ESMFold model\nmodel = esm.pretrained.esm1v_t33_650M_UR90S_5()\nmodel = model.eval().cuda()\n\n# Set the input sequence\nsequence = \"MKTVRQERLKSIVRILERSKEPV\"\n\n# Perform structure prediction\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\n# Save the output structure to a PDB file\nwith open(\"model_structure.pdb\", \"w\") as f:\n    f.write(output)\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 3, "path": "./", "arguments": "{'model': 'esm_if1_gvp4_t16_142M_UR50', 'data': 'cov19.fasta', 'layer_number': 25, 'output_dir': 'model_embeddings.emb', 'argument1': 'repr_layers'}", "instruction": "Can you assist me in writing the code to extract the 25-layer embedding for a FASTA file cov19.fasta using the esm_if1_gvp4_t16_142M_UR50 model and save the output to model_embeddings.emb?", "oracle": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n", "type": "Bash Script", "id": 154, "prefix_code": "", "output": "\npython scripts/extract.py esm_if1_gvp4_t16_142M_UR50 cov19.fasta model_embeddings.emb --repr_layers 25 --include mean per_tok\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 4, "path": "./", "arguments": "{'model': 'esm2_t48_15B_UR50D', 'data': 'cov19.fasta', 'layer_number': 0, 'output_dir': 'model_embeddings.emb', 'argument1': 'repr_layers'}", "instruction": "Can you assist me in writing the code to extract the 0-layer embedding for a FASTA file cov19.fasta using the esm2_t48_15B_UR50D model and save the output to model_embeddings.emb?", "oracle": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n", "type": "Bash Script", "id": 155, "prefix_code": "", "output": "\npython scripts/extract.py esm2_t48_15B_UR50D cov19.fasta model_embeddings.emb --repr_layers 0 --include mean per_tok\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 7, "path": "./", "arguments": "{'model': 'esm2_t36_3B_UR50D', 'data': 'dna_virus.fasta', 'layer_number': 31, 'argument1': 'repr_layers'}", "instruction": "Can you assist me in writing the code to extract the 31-layer embedding for a FASTA file dna_virus.fasta using the esm2_t36_3B_UR50D model and save the output?", "oracle": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n", "type": "Bash Script", "id": 157, "prefix_code": "", "output": "\npython scripts/extract.py esm2_t36_3B_UR50D dna_virus.fasta output.embeddings --repr_layers 31 --include mean per_tok\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 10, "path": "./", "arguments": "{'model': 'esm1v_t33_650M_UR90S_5', 'data': 'rna.fasta', 'layer_number': 24, 'argument1': 'repr_layers'}", "instruction": "Can you assist me in writing the code to extract the 24-layer embedding for a FASTA file named rna.fasta using the esm1v_t33_650M_UR90S_5 model and save the output?", "oracle": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n", "type": "Bash Script", "id": 161, "prefix_code": "", "output": "\npython scripts/extract.py esm1v_t33_650M_UR90S_5 rna.fasta output.embeddings --repr_layers 24 --include mean per_tok\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 11, "path": "./", "arguments": "{'model': 'esm_msa1b_t12_100M_UR50S', 'data': 'cov19.fasta', 'layer_number': 58, 'output_dir': 'model_embeddings.emb', 'argument1': 'repr_layers'}", "instruction": "Can you assist me in writing the code to extract the 58-layer embedding for the FASTA file cov19.fasta using the esm_msa1b_t12_100M_UR50S model and save the output to model_embeddings.emb?", "oracle": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n", "type": "Bash Script", "id": 162, "prefix_code": "", "output": "\npython scripts/extract.py esm_msa1b_t12_100M_UR50S cov19.fasta model_embeddings.emb --repr_layers 58 --include mean per_tok\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 13, "path": "./", "arguments": "{'data': '5YH2.pdb', 'num_samples': 3, 'chain': 'B', 'temperature': 1, 'output_dir': 'model_structure.fasta'}", "instruction": "Can you assist me in writing the code to extract 3 designs from the structure 5YH2.pdb, specifically from chain B, at a temperature of 1? The output should be saved to the file model_structure.fasta.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 164, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py 5YH2.pdb   --chain B --temperature 1 --num-samples 3 --outpath model_structure.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 14, "path": "./", "arguments": "{'data': 'Fam20A.pdb', 'num_samples': 5, 'chain': 'B', 'temperature': 3}", "instruction": "Can you assist me in writing the code to extract 5 designs from the structure Fam20A.pdb with chain B at a temperature of 3 and then output the results?", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 165, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20A.pdb   --chain B --temperature 3 --num-samples 5 --outpath output.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 17, "path": "./", "arguments": "{'data': 'Fam20A.pdb', 'num_samples': 5, 'chain': 'B', 'temperature': 8}", "instruction": "Can you assist me in writing the code to extract 5 designs from the structure Fam20A.pdb, specifically from chain B, at a temperature of 8? I would like the output to be returned.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 168, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20A.pdb   --chain B --temperature 8 --num-samples 5 --outpath output.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 18, "path": "./", "arguments": "{'data': '5YH2.pdb', 'num_samples': 3, 'chain': 'B', 'temperature': 3, 'output_dir': 'model_structure.fasta'}", "instruction": "Can you assist me in writing the code to extract 3 designs from the structure 5YH2.pdb, specifically from chain B, at a temperature of 3? The output should be saved to the file model_structure.fasta.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 169, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py 5YH2.pdb   --chain B --temperature 3 --num-samples 3 --outpath model_structure.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 19, "path": "./", "arguments": "{'data': 'Fam20A.pdb', 'num_samples': 9, 'chain': 'C', 'temperature': 1, 'output_dir': 'model_structure.fasta'}", "instruction": "Can you assist me in writing the code to extract 9 designs from structure Fam20A.pdb, specifically from chain C, at a temperature of 1? The output should be saved to model_structure.fasta.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 170, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20A.pdb   --chain C --temperature 1 --num-samples 9 --outpath model_structure.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 20, "path": "./", "arguments": "{'data': 'Fam20B.pdb', 'num_samples': 5, 'chain': 'A', 'temperature': 3}", "instruction": "Can you assist me in writing the code to extract 5 designs from structure Fam20B.pdb, specifically from chain A, at a temperature of 3? I would like to output the results.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 171, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20B.pdb   --chain A --temperature 3 --num-samples 5 --outpath output.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 21, "path": "./", "arguments": "{'data': 'examples/inverse_folding/data/5YH2.pdb', 'num_samples': 3, 'chain': 'B', 'temperature': 3}", "instruction": "Can you assist me in writing the code to sample 3 designs of structure examples/inverse_folding/data/5YH2.pdb with chain B at temperature 3 and then output the results?", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 172, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain B --temperature 3 --num-samples 3 --outpath output.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 23, "path": "./", "arguments": "{'data': 'Fam20B.pdb', 'num_samples': 3, 'chain': 'C', 'temperature': 1}", "instruction": "Can you assist me in writing the code to extract 3 designs from the structure Fam20B.pdb, specifically from chain C, at a temperature of 1, and then output the results?", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 174, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20B.pdb   --chain C --temperature 1 --num-samples 3 --outpath output.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 25, "path": "./", "arguments": "{'data': '5YH2.pdb', 'num_samples': 3, 'chain': 'A', 'temperature': 5, 'output_dir': 'model_structure.fasta'}", "instruction": "Can you assist me in writing the code to extract 3 structure examples from the inverse_folding data file 5YH2.pdb? I specifically need designs with chain A at a temperature of 5. The output should be saved in the model_structure.fasta file.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 176, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain A --temperature 5 --num-samples 3 --outpath model_structure.fasta\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 26, "path": "./", "arguments": "{'data': 'Fam20B.pdb', 'num_samples': 1, 'chain': 'A', 'temperature': 8, 'output_dir': 'output.fasta'}", "instruction": "Can you assist me in writing the code to extract 1 design from the Fam20B.pdb structure file, specifically from chain A, at a temperature of 8? The output should be saved in the output.fasta file.", "oracle": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n", "type": "Bash Script", "id": 177, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20B.pdb   --chain A --temperature 8 --num-samples 1 --outpath output.fasta\n"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 1, "path": "./implementations/ebgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'ebgan'}", "instruction": "I have a task to work with the Energy-Based GAN model. The learning rate for this task needs to be set at 0.0001, the number of training epochs should be defined as 100, and the batch size should be fixed at 16. Furthermore, I want the image size to be set at 128. Can you please assist me in framing the script to facilitate this?", "oracle": "Energy-Based GAN  \n Energy-based Generative Adversarial Network  \n Authors  \n Junbo Zhao, Michael Mathieu, Yann LeCun  \n Abstract  \n We introduce the \"Energy-based Generative Adversarial Network\" model (EBGAN) which views the discriminator as an energy function that attributes low energies to the regions near the data manifold and higher energies to other regions. Similar to the probabilistic GANs, a generator is seen as being trained to produce contrastive samples with minimal energies, while the discriminator is trained to assign high energies to these generated samples. Viewing the discriminator as an energy function allows to use a wide variety of architectures and loss functionals in addition to the usual binary classifier with logistic output. Among them, we show one instantiation of EBGAN framework as using an auto-encoder architecture, with the energy being the reconstruction error, in place of the discriminator. We show that this form of EBGAN exhibits more stable behavior than regular GANs during training. We also show that a single-scale architecture can be trained to generate high-resolution images.  \n [Paper] [Code]  \n Run Example  \n $ cd implementations/ebgan/  \n $ python3 ebgan.py", "type": "Bash Script", "id": 2, "prefix_code": "", "output": "python3 ebgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 2, "path": "./implementations/dcgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'dcgan'}", "instruction": "I wish to employ a Deep Convolutional GAN for a specific task. For this, assign the learning rate parameter to 0.0001, while set the number of training epochs to 100 for optimal training. Additionally, I want the batch size parameter to read 16. Furthermore, it's vital to configure the image size parameter at 128 to meet the requirement. could you guide me in crafting the necessary code for this?", "oracle": "Deep Convolutional GAN \n Deep Convolutional Generative Adversarial Network \n Authors \n Alec Radford, Luke Metz, Soumith Chintala \n Abstract \n In recent years, supervised learning with convolutional networks (CNNs) has seen huge adoption in computer vision applications. Comparatively, unsupervised learning with CNNs has received less attention. In this work we hope to help bridge the gap between the success of CNNs for supervised learning and unsupervised learning. We introduce a class of CNNs called deep convolutional generative adversarial networks (DCGANs), that have certain architectural constraints, and demonstrate that they are a strong candidate for unsupervised learning. Training on various image datasets, we show convincing evidence that our deep convolutional adversarial pair learns a hierarchy of representations from object parts to scenes in both the generator and discriminator. Additionally, we use the learned features for novel tasks - demonstrating their applicability as general image representations. \n [Paper] [Code] \n Run Example \n $ cd implementations/dcgan/ \n $ python3 dcgan.py", "type": "Bash Script", "id": 6, "prefix_code": "", "output": "python3 dcgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 3, "path": "./implementations/relativistic_gan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'relativistic_gan'}", "instruction": "I am keen to employ the Relativistic GAN model and configure it with a learning rate of 0.0001. Furthermore, I surmise that allocating 100 training epochs would be ideal for my needs. I also intend to set a batch size of 16 and an image size of 128. Would you be capable of assisting me with drafting the pertinent code?", "oracle": "Relativistic GAN \n The relativistic discriminator: a key element missing from standard GAN \n Authors \n Alexia Jolicoeur-Martineau \n Abstract \n In standard generative adversarial network (SGAN), the discriminator estimates the probability that the input data is real. The generator is trained to increase the probability that fake data is real. We argue that it should also simultaneously decrease the probability that real data is real because 1) this would account for a priori knowledge that half of the data in the mini-batch is fake, 2) this would be observed with divergence minimization, and 3) in optimal settings, SGAN would be equivalent to integral probability metric (IPM) GANs. We show that this property can be induced by using a relativistic discriminator which estimate the probability that the given real data is more realistic than a randomly sampled fake data. We also present a variant in which the discriminator estimate the probability that the given real data is more realistic than fake data, on average. We generalize both approaches to non-standard GAN loss functions and we refer to them respectively as Relativistic GANs (RGANs) and Relativistic average GANs (RaGANs). We show that IPM-based GANs are a subset of RGANs which use the identity function. Empirically, we observe that 1) RGANs and RaGANs are significantly more stable and generate higher quality data samples than their non-relativistic counterparts, 2) Standard RaGAN with gradient penalty generate data of better quality than WGAN-GP while only requiring a single discriminator update per generator update (reducing the time taken for reaching the state-of-the-art by 400%), and 3) RaGANs are able to generate plausible high resolutions images (256x256) from a very small sample (N=2011), while GAN and LSGAN cannot; these images are of significantly better quality than the ones generated by WGAN-GP and SGAN with spectral normalization. \n [Paper] [Code] \n Run Example \n $ cd implementations/relativistic_gan/ \n $ python3 relativistic_gan.py                 # Relativistic Standard GAN \n $ python3 relativistic_gan.py --rel_avg_gan   # Relativistic Average GAN", "type": "Bash Script", "id": 7, "prefix_code": "", "output": "python3 relativistic_gan.py --rel_avg_gan   # Relativistic Average GAN --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 4, "path": "./implementations/pixelda/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'pixelda'}", "instruction": "I'm aiming to use the PixelDA model for a task. To do so, I need to adjust certain parameters. Can you help me write some code that sets the learning rate to 0.0001, the number of training epochs to 100, the batch size to 16, and the image size to 128? I need some assistance laying out the syntax for this process.", "oracle": "PixelDA  \n Unsupervised Pixel-Level Domain Adaptation with Generative Adversarial Networks  \n Authors  \n Konstantinos Bousmalis, Nathan Silberman, David Dohan, Dumitru Erhan, Dilip Krishnan  \n Abstract  \n Collecting well-annotated image datasets to train modern machine learning algorithms is prohibitively expensive for many tasks. One appealing alternative is rendering synthetic data where ground-truth annotations are generated automatically. Unfortunately, models trained purely on rendered images often fail to generalize to real images. To address this shortcoming, prior work introduced unsupervised domain adaptation algorithms that attempt to map representations between the two domains or learn to extract features that are domain-invariant. In this work, we present a new approach that learns, in an unsupervised manner, a transformation in the pixel space from one domain to the other. Our generative adversarial network (GAN)-based method adapts source-domain images to appear as if drawn from the target domain. Our approach not only produces plausible samples, but also outperforms the state-of-the-art on a number of unsupervised domain adaptation scenarios by large margins. Finally, we demonstrate that the adaptation process generalizes to object classes unseen during training.  \n [Paper] [Code]  \n MNIST to MNIST-M Classification  \n Trains a classifier on images that have been translated from the source domain (MNIST) to the target domain (MNIST-M) using the annotations of the source domain images. The classification network is trained jointly with the generator network to optimize the generator for both providing a proper domain translation and also for preserving the semantics of the source domain image. The classification network trained on translated images is compared to the naive solution of training a classifier on MNIST and evaluating it on MNIST-M. The naive model manages a 55% classification accuracy on MNIST-M while the one trained during domain adaptation achieves a 95% classification accuracy.  \n $ cd implementations/pixelda/  \n $ python3 pixelda.py  \n Method\tAccuracy  \n Naive\t55%  \n PixelDA\t95%", "type": "Bash Script", "id": 9, "prefix_code": "", "output": "python3 pixelda.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 5, "path": "./implementations/wgan_gp/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'wgan_gp'}", "instruction": "I'm interested in deploying the Wasserstein GAN GP model for a particular task. The parameters I'm aiming for are a learning rate of 0.0001, 100 training epochs, a batch size of 16, and an image size of 128. Can you assist me in formulating the appropriate code for these specs?", "oracle": "Wasserstein GAN GP \n Improved Training of Wasserstein GANs \n Authors \n Ishaan Gulrajani, Faruk Ahmed, Martin Arjovsky, Vincent Dumoulin, Aaron Courville \n Abstract \n Generative Adversarial Networks (GANs) are powerful generative models, but suffer from training instability. The recently proposed Wasserstein GAN (WGAN) makes progress toward stable training of GANs, but sometimes can still generate only low-quality samples or fail to converge. We find that these problems are often due to the use of weight clipping in WGAN to enforce a Lipschitz constraint on the critic, which can lead to undesired behavior. We propose an alternative to clipping weights: penalize the norm of gradient of the critic with respect to its input. Our proposed method performs better than standard WGAN and enables stable training of a wide variety of GAN architectures with almost no hyperparameter tuning, including 101-layer ResNets and language models over discrete data. We also achieve high quality generations on CIFAR-10 and LSUN bedrooms. \n [Paper] [Code] \n Run Example \n $ cd implementations/wgan_gp/ \n $ python3 wgan_gp.py", "type": "Bash Script", "id": 10, "prefix_code": "", "output": "python3 wgan_gp.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 6, "path": "./implementations/infogan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'InfoGAN'}", "instruction": "I have selected InfoGAN as my chosen model and I am aiming to adjust a few of its parameters. I would like to set the learning rate to be 0.0001. Next, my intention is to define the number of training epochs as 100. For the training process, it's essential to adjust the batch size to 16. Lastly, I would confine the size of the image to 128. Consequently, I need some coding assistance to fulfil this task. Would you mind helping me to write a piece of code that embodies these specifications?", "oracle": "InfoGAN \n InfoGAN: Interpretable Representation Learning by Information Maximizing Generative Adversarial Nets \n Authors \n Xi Chen, Yan Duan, Rein Houthooft, John Schulman, Ilya Sutskever, Pieter Abbeel \n Abstract \n This paper describes InfoGAN, an information-theoretic extension to the Generative Adversarial Network that is able to learn disentangled representations in a completely unsupervised manner. InfoGAN is a generative adversarial network that also maximizes the mutual information between a small subset of the latent variables and the observation. We derive a lower bound to the mutual information objective that can be optimized efficiently, and show that our training procedure can be interpreted as a variation of the Wake-Sleep algorithm. Specifically, InfoGAN successfully disentangles writing styles from digit shapes on the MNIST dataset, pose from lighting of 3D rendered images, and background digits from the central digit on the SVHN dataset. It also discovers visual concepts that include hair styles, presence/absence of eyeglasses, and emotions on the CelebA face dataset. Experiments show that InfoGAN learns interpretable representations that are competitive with representations learned by existing fully supervised methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/infogan/ \n $ python3 infogan.py", "type": "Bash Script", "id": 11, "prefix_code": "", "output": "python3 infogan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 7, "path": "./implementations/dualgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'DualGAN'}", "instruction": "I plan to use the DualGAN model. Please assist me in writing the code, taking into account the below mentioned parameters: I'd like the learning rate to be set to 0.0001, the batch size to be 16, the number of training epochs to be 100 and the image size to be set to 128. Thank you.", "oracle": "DualGAN \n DualGAN: Unsupervised Dual Learning for Image-to-Image Translation \n Authors \n Zili Yi, Hao Zhang, Ping Tan, Minglun Gong \n Abstract \n Conditional Generative Adversarial Networks (GANs) for cross-domain image-to-image translation have made much progress recently. Depending on the task complexity, thousands to millions of labeled image pairs are needed to train a conditional GAN. However, human labeling is expensive, even impractical, and large quantities of data may not always be available. Inspired by dual learning from natural language translation, we develop a novel dual-GAN mechanism, which enables image translators to be trained from two sets of unlabeled images from two domains. In our architecture, the primal GAN learns to translate images from domain U to those in domain V, while the dual GAN learns to invert the task. The closed loop made by the primal and dual tasks allows images from either domain to be translated and then reconstructed. Hence a loss function that accounts for the reconstruction error of images can be used to train the translators. Experiments on multiple image translation tasks with unlabeled data show considerable performance gain of DualGAN over a single GAN. For some tasks, DualGAN can even achieve comparable or slightly better results than conditional GAN trained on fully labeled data. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_pix2pix_dataset.sh facades \n $ cd ../implementations/dualgan/ \n $ python3 dualgan.py --dataset_name facades", "type": "Bash Script", "id": 12, "prefix_code": "$ cd data/ \n$ bash download_pix2pix_dataset.sh facades", "output": "python3 dualgan.py --dataset_name facades --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 8, "path": "./implementations/wgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'wgan'}", "instruction": "I require assistance with devising a code. The goal is to employ the Wasserstein GAN model for a project. I intend to set the learning rate at 0.0001, schedule the number of training epochs at 100, batch size at 16, and fix the image size at 128. Can you please guide me through the process of developing this code?", "oracle": "Wasserstein GAN \n Wasserstein GAN \n Authors \n Martin Arjovsky, Soumith Chintala, L\u00e9on Bottou \n Abstract \n We introduce a new algorithm named WGAN, an alternative to traditional GAN training. In this new model, we show that we can improve the stability of learning, get rid of problems like mode collapse, and provide meaningful learning curves useful for debugging and hyperparameter searches. Furthermore, we show that the corresponding optimization problem is sound, and provide extensive theoretical work highlighting the deep connections to other distances between distributions. \n [Paper] [Code] \n Run Example \n $ cd implementations/wgan/ \n $ python3 wgan.py", "type": "Bash Script", "id": 14, "prefix_code": "", "output": "python3 wgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 9, "path": "./implementations/cogan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'cogan'}", "instruction": "I'm aiming to leverage the capabilities of Coupled GAN for my project and I need assistance in setting up the configuration. Specifically, I want to set the learning rate at 0.0001, train the model for 100 epochs, with a batch size of 16. Furthermore, I want to configure the image size to be 128. Could you aid me in drafting the requisite Python implementation for this configuration?", "oracle": "Coupled GAN \n Coupled Generative Adversarial Networks \n Authors \n Ming-Yu Liu, Oncel Tuzel \n Abstract \n We propose coupled generative adversarial network (CoGAN) for learning a joint distribution of multi-domain images. In contrast to the existing approaches, which require tuples of corresponding images in different domains in the training set, CoGAN can learn a joint distribution without any tuple of corresponding images. It can learn a joint distribution with just samples drawn from the marginal distributions. This is achieved by enforcing a weight-sharing constraint that limits the network capacity and favors a joint distribution solution over a product of marginal distributions one. We apply CoGAN to several joint distribution learning tasks, including learning a joint distribution of color and depth images, and learning a joint distribution of face images with different attributes. For each task it successfully learns the joint distribution without any tuple of corresponding images. We also demonstrate its applications to domain adaptation and image transformation. \n [Paper] [Code] \n Run Example \n $ cd implementations/cogan/ \n $ python3 cogan.py", "type": "Bash Script", "id": 15, "prefix_code": "", "output": "python3 cogan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 10, "path": "./implementations/softmax_gan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'softmax_gan'}", "instruction": "I'm keen on using the Softmax GAN model to perform a certain task. To optimise the model's performance, please adjust the learning rate to 0.0001, the number of training epochs to 100, the batch size to 16 and the image size to 128. Could you aid me in crafting the sufficient code for these specifications?", "oracle": "Softmax GAN \n Softmax GAN \n Authors \n Min Lin \n Abstract \n Softmax GAN is a novel variant of Generative Adversarial Network (GAN). The key idea of Softmax GAN is to replace the classification loss in the original GAN with a softmax cross-entropy loss in the sample space of one single batch. In the adversarial learning of N real training samples and M generated samples, the target of discriminator training is to distribute all the probability mass to the real samples, each with probability 1M, and distribute zero probability to generated data. In the generator training phase, the target is to assign equal probability to all data points in the batch, each with probability 1M+N. While the original GAN is closely related to Noise Contrastive Estimation (NCE), we show that Softmax GAN is the Importance Sampling version of GAN. We futher demonstrate with experiments that this simple change stabilizes GAN training. \n [Paper] [Code] \n Run Example \n $ cd implementations/softmax_gan/ \n $ python3 softmax_gan.py", "type": "Bash Script", "id": 16, "prefix_code": "", "output": "python3 softmax_gan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 11, "path": "./implementations/lsgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'lsgan'}", "instruction": "I'm hoping to implement some programming involving the Least Squares GAN model. My plan is to set the learning rate at 0.0001, and I'd like to go for 100 epochs during training. Also, my preference is to keep the batch size at 16 and the image size at 128. Could you possibly assist me in generating the necessary code?", "oracle": "Least Squares GAN \n Least Squares Generative Adversarial Networks \n Authors \n Xudong Mao, Qing Li, Haoran Xie, Raymond Y.K. Lau, Zhen Wang, Stephen Paul Smolley \n Abstract \n Unsupervised learning with generative adversarial networks (GANs) has proven hugely successful. Regular GANs hypothesize the discriminator as a classifier with the sigmoid cross entropy loss function. However, we found that this loss function may lead to the vanishing gradients problem during the learning process. To overcome such a problem, we propose in this paper the Least Squares Generative Adversarial Networks (LSGANs) which adopt the least squares loss function for the discriminator. We show that minimizing the objective function of LSGAN yields minimizing the Pearson \u03c72 divergence. There are two benefits of LSGANs over regular GANs. First, LSGANs are able to generate higher quality images than regular GANs. Second, LSGANs perform more stable during the learning process. We evaluate LSGANs on five scene datasets and the experimental results show that the images generated by LSGANs are of better quality than the ones generated by regular GANs. We also conduct two comparison experiments between LSGANs and regular GANs to illustrate the stability of LSGANs. \n [Paper] [Code] \n Run Example \n $ cd implementations/lsgan/ \n $ python3 lsgan.py", "type": "Bash Script", "id": 18, "prefix_code": "", "output": "python3 lsgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 12, "path": "./implementations/sgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'sgan'}", "instruction": "I'm looking to utilize Semi-Supervised GAN in my machine learning project. I need to set the learning rate to 0.0001, define the number of training epochs to 100, and adjust the batch size to 16. Furthermore, the image size should be set to 128. Could you assist me by writing the necessary code to implement this?", "oracle": "Semi-Supervised GAN  \n Semi-Supervised Generative Adversarial Network  \n Authors  \n Augustus Odena  \n Abstract  \n We extend Generative Adversarial Networks (GANs) to the semi-supervised context by forcing the discriminator network to output class labels. We train a generative model G and a discriminator D on a dataset with inputs belonging to one of N classes. At training time, D is made to predict which of N+1 classes the input belongs to, where an extra class is added to correspond to the outputs of G. We show that this method can be used to create a more data-efficient classifier and that it allows for generating higher quality samples than a regular GAN.  \n [Paper] [Code]  \n Run Example  \n $ cd implementations/sgan/  \n $ python3 sgan.py", "type": "Bash Script", "id": 20, "prefix_code": "", "output": "python3 sgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 13, "path": "./implementations/acgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'model': 'acgan'}", "instruction": "I require some assistance in developing code for the implementation of an Auxiliary Classifier GAN. I would like to utilize a learning rate of 0.0001, and run the model for a total of 100 epochs. Further, the batch size should be set to 16 and the image size ought be set at 128. Could you help me formulate the proper code for the aforementioned tasks?", "oracle": "Auxiliary Classifier GAN \n Auxiliary Classifier Generative Adversarial Network \n Authors \n Augustus Odena, Christopher Olah, Jonathon Shlens \n Abstract \\ Synthesizing high resolution photorealistic images has been a long-standing challenge in machine learning. In this paper we introduce new methods for the improved training of generative adversarial networks (GANs) for image synthesis. We construct a variant of GANs employing label conditioning that results in 128x128 resolution image samples exhibiting global coherence. We expand on previous work for image quality assessment to provide two new analyses for assessing the discriminability and diversity of samples from class-conditional image synthesis models. These analyses demonstrate that high resolution samples provide class information not present in low resolution samples. Across 1000 ImageNet classes, 128x128 samples are more than twice as discriminable as artificially resized 32x32 samples. In addition, 84.7% of the classes have samples exhibiting diversity comparable to real ImageNet data. \n [Paper] [Code] \n Run Example \n $ cd implementations/acgan/ \n $ python3 acgan.py", "type": "Bash Script", "id": 22, "prefix_code": "", "output": "python3 acgan.py --lr 0.0001 --n_epochs 100"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 14, "path": "./implementations/wgan_div/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'wgan_div'}", "instruction": "My task involves employing the Wasserstein GAN DIV model and setting the learning rate at 0.0001. Additionally, I aim to execute 100 training epochs with a batch size of 16. The size of each image in the batch will be 128. As such, could you assist in scripting the necessary code to achieve this?", "oracle": "Wasserstein GAN DIV \n Wasserstein Divergence for GANs \n Authors \n Jiqing Wu, Zhiwu Huang, Janine Thoma, Dinesh Acharya, Luc Van Gool \n Abstract \n In many domains of computer vision, generative adversarial networks (GANs) have achieved great success, among which the fam- ily of Wasserstein GANs (WGANs) is considered to be state-of-the-art due to the theoretical contributions and competitive qualitative performance. However, it is very challenging to approximate the k-Lipschitz constraint required by the Wasserstein-1 metric (W-met). In this paper, we propose a novel Wasserstein divergence (W-div), which is a relaxed version of W-met and does not require the k-Lipschitz constraint.As a concrete application, we introduce a Wasserstein divergence objective for GANs (WGAN-div), which can faithfully approximate W-div through optimization. Under various settings, including progressive growing training, we demonstrate the stability of the proposed WGAN-div owing to its theoretical and practical advantages over WGANs. Also, we study the quantitative and visual performance of WGAN-div on standard image synthesis benchmarks, showing the superior performance of WGAN-div compared to the state-of-the-art methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/wgan_div/ \n $ python3 wgan_div.py", "type": "Bash Script", "id": 23, "prefix_code": "", "output": "python3 wgan_div.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 15, "path": "./implementations/dragan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'dragan'}", "instruction": "I am planning on utilizing the DRAGAN model for a task in hand and I wish to set the learning rate for this model to 0.0001. As for the number of training epochs, I have decided to go with 100. The batch size I've chosen is 16 and the image size will be 128. Could you be of assistance in coding this out?", "oracle": "DRAGAN \n On Convergence and Stability of GANs \n Authors \n Naveen Kodali, Jacob Abernethy, James Hays, Zsolt Kira \n Abstract \n We propose studying GAN training dynamics as regret minimization, which is in contrast to the popular view that there is consistent minimization of a divergence between real and generated distributions. We analyze the convergence of GAN training from this new point of view to understand why mode collapse happens. We hypothesize the existence of undesirable local equilibria in this non-convex game to be responsible for mode collapse. We observe that these local equilibria often exhibit sharp gradients of the discriminator function around some real data points. We demonstrate that these degenerate local equilibria can be avoided with a gradient penalty scheme called DRAGAN. We show that DRAGAN enables faster training, achieves improved stability with fewer mode collapses, and leads to generator networks with better modeling performance across a variety of architectures and objective functions. \n [Paper] [Code] \n Run Example \n $ cd implementations/dragan/ \n $ python3 dragan.py", "type": "Bash Script", "id": 24, "prefix_code": "", "output": "python3 dragan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 16, "path": "./implementations/bgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'bgan'}", "instruction": "With the task at hand, my choice of model is the Boundary-Seeking GAN. I intend to set the learning rate at 0.0001 and desire the training to continue for a hundred epochs. On top of that, I wish to organize the training data in batches of 16 for each epoch, and set the image size to 128. Can you kindly assist me by providing an illustrative code snippet to carry out this task?", "oracle": "Boundary-Seeking GAN \n Boundary-Seeking Generative Adversarial Networks \n Authors \n R Devon Hjelm, Athul Paul Jacob, Tong Che, Adam Trischler, Kyunghyun Cho, Yoshua Bengio \n Abstract \n Generative adversarial networks (GANs) are a learning framework that rely on training a discriminator to estimate a measure of difference between a target and generated distributions. GANs, as normally formulated, rely on the generated samples being completely differentiable w.r.t. the generative parameters, and thus do not work for discrete data. We introduce a method for training GANs with discrete data that uses the estimated difference measure from the discriminator to compute importance weights for generated samples, thus providing a policy gradient for training the generator. The importance weights have a strong connection to the decision boundary of the discriminator, and we call our method boundary-seeking GANs (BGANs). We demonstrate the effectiveness of the proposed algorithm with discrete image and character-based natural language generation. In addition, the boundary-seeking objective extends to continuous data, which can be used to improve stability of training, and we demonstrate this on Celeba, Large-scale Scene Understanding (LSUN) bedrooms, and Imagenet without conditioning. \n [Paper] [Code] \n Run Example \n $ cd implementations/bgan/ \n $ python3 bgan.py", "type": "Bash Script", "id": 25, "prefix_code": "", "output": "python3 bgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 17, "path": "./implementations/cgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'cgan'}", "instruction": "I am looking to employ a Conditional GAN. I would like to program it with a learning rate of 0.0001 along with 100 training epochs. Moreover, I will need to set the batch size to 16 and the image size parameter to 128. Your assistance in constructing the necessary code would be greatly appreciated.", "oracle": "Conditional GAN \n Conditional Generative Adversarial Nets \n Authors \n Mehdi Mirza, Simon Osindero \n Abstract \n Generative Adversarial Nets [8] were recently introduced as a novel way to train generative models. In this work we introduce the conditional version of generative adversarial nets, which can be constructed by simply feeding the data, y, we wish to condition on to both the generator and discriminator. We show that this model can generate MNIST digits conditioned on class labels. We also illustrate how this model could be used to learn a multi-modal model, and provide preliminary examples of an application to image tagging in which we demonstrate how this approach can generate descriptive tags which are not part of training labels. \n [Paper] [Code] \n Run Example \n $ cd implementations/cgan/ \n $ python3 cgan.py", "type": "Bash Script", "id": 27, "prefix_code": "", "output": "python3 cgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 18, "path": "./implementations/esrgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'esrgan'}", "instruction": "The model that I prefer to use is Enhanced Super-Resolution GAN. Moreover, I'd like to set the learning rate to 0.0001 and run it for 100 training epochs. I plan on setting the batch size to 16 and the image size to 128. I'm hoping you could assist me by generating some practical code that adheres to these specifications.", "oracle": "Enhanced Super-Resolution GAN \n ESRGAN: Enhanced Super-Resolution Generative Adversarial Networks \n Authors \n Xintao Wang, Ke Yu, Shixiang Wu, Jinjin Gu, Yihao Liu, Chao Dong, Chen Change Loy, Yu Qiao, Xiaoou Tang \n Abstract \n The Super-Resolution Generative Adversarial Network (SRGAN) is a seminal work that is capable of generating realistic textures during single image super-resolution. However, the hallucinated details are often accompanied with unpleasant artifacts. To further enhance the visual quality, we thoroughly study three key components of SRGAN - network architecture, adversarial loss and perceptual loss, and improve each of them to derive an Enhanced SRGAN (ESRGAN). In particular, we introduce the Residual-in-Residual Dense Block (RRDB) without batch normalization as the basic network building unit. Moreover, we borrow the idea from relativistic GAN to let the discriminator predict relative realness instead of the absolute value. Finally, we improve the perceptual loss by using the features before activation, which could provide stronger supervision for brightness consistency and texture recovery. Benefiting from these improvements, the proposed ESRGAN achieves consistently better visual quality with more realistic and natural textures than SRGAN and won the first place in the PIRM2018-SR Challenge. The code is available at this https URL.\n [Paper] [Code]\n Run Example \n $ cd implementations/esrgan/ \n <follow steps at the top of esrgan.py> \n $ python3 esrgan.py", "type": "Bash Script", "id": 3, "prefix_code": "", "output": "python3 esrgan.py --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 19, "path": "./implementations/stargan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'StarGAN'}", "instruction": "I'm thinking of utilizing StarGAN for a specific task, with a learning rate structured at 0.0001 and the training duration leading up to 100 epochs. Kindly set the batch size at 16, along with an image size that fits 128 pixels. Could you kindly assist in providing me with some example code to follow?", "oracle": "StarGAN  \n StarGAN: Unified Generative Adversarial Networks for Multi-Domain Image-to-Image Translation  \n Authors  \n Yunjey Choi, Minje Choi, Munyoung Kim, Jung-Woo Ha, Sunghun Kim, Jaegul Choo  \n Abstract  \n Recent studies have shown remarkable success in image-to-image translation for two domains. However, existing approaches have limited scalability and robustness in handling more than two domains, since different models should be built independently for every pair of image domains. To address this limitation, we propose StarGAN, a novel and scalable approach that can perform image-to-image translations for multiple domains using only a single model. Such a unified model architecture of StarGAN allows simultaneous training of multiple datasets with different domains within a single network. This leads to StarGAN's superior quality of translated images compared to existing models as well as the novel capability of flexibly translating an input image to any desired target domain. We empirically demonstrate the effectiveness of our approach on a facial attribute transfer and a facial expression synthesis tasks.  \n [Paper] [Code]  \n Run Example  \n $ cd implementations/stargan/  \n <follow steps at the top of stargan.py>  \n $ python3 stargan.py", "type": "Bash Script", "id": 4, "prefix_code": "", "output": "python3 stargan.py --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 20, "path": "./implementations/unit/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'UNIT'}", "instruction": "I'm hoping to facilitate my task with the use of UNIT model. Can you aid me in setting the learning rate at 0.0001, defining the number of training epochs to reach 100, allocating batch size to 16, and adjusting the image size to 128? I'm in need of some example code for this.", "oracle": "UNIT \n Unsupervised Image-to-Image Translation Networks \n Authors \n Ming-Yu Liu, Thomas Breuel, Jan Kautz \n Abstract \n Unsupervised image-to-image translation aims at learning a joint distribution of images in different domains by using images from the marginal distributions in individual domains. Since there exists an infinite set of joint distributions that can arrive the given marginal distributions, one could infer nothing about the joint distribution from the marginal distributions without additional assumptions. To address the problem, we make a shared-latent space assumption and propose an unsupervised image-to-image translation framework based on Coupled GANs. We compare the proposed framework with competing approaches and present high quality image translation results on various challenging unsupervised image translation tasks, including street scene image translation, animal image translation, and face image translation. We also apply the proposed framework to domain adaptation and achieve state-of-the-art performance on benchmark datasets. Code and additional results are available in this https URL. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_cyclegan_dataset.sh apple2orange \n $ cd implementations/unit/ \n $ python3 unit.py --dataset_name apple2orange", "type": "Bash Script", "id": 5, "prefix_code": "$ cd data/ \n$ bash download_cyclegan_dataset.sh apple2orange", "output": "python3 unit.py --dataset_name apple2orange --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 21, "path": "./implementations/discogan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'DiscoGAN'}", "instruction": "I aim to utilize the DiscoGAN model for my project. The learning rate needs to be adjusted to 0.0001 and I would very much appreciate it if you could guide me in setting the number of training epochs to 100. Also, the batch size should be fixed at 16. Besides that, please help me adjust the image size to 128. I am asking for your assistance in writing the necessary code to accomplish this.", "oracle": "DiscoGAN \n Learning to Discover Cross-Domain Relations with Generative Adversarial Networks \n Authors \n Taeksoo Kim, Moonsu Cha, Hyunsoo Kim, Jung Kwon Lee, Jiwon Kim \n Abstract \n While humans easily recognize relations between data from different domains without any supervision, learning to automatically discover them is in general very challenging and needs many ground-truth pairs that illustrate the relations. To avoid costly pairing, we address the task of discovering cross-domain relations given unpaired data. We propose a method based on generative adversarial networks that learns to discover relations between different domains (DiscoGAN). Using the discovered relations, our proposed network successfully transfers style from one domain to another while preserving key attributes such as orientation and face identity. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_pix2pix_dataset.sh edges2shoes \n $ cd ../implementations/discogan/ \n $ python3 discogan.py --dataset_name edges2shoes", "type": "Bash Script", "id": 8, "prefix_code": "$ cd data/ \n$ bash download_pix2pix_dataset.sh edges2shoes", "output": "python3 discogan.py --dataset_name edges2shoes --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 22, "path": "./implementations/pix2pix/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'Pix2Pix'}", "instruction": "I have a task planned to be executed with the Pix2Pix model. As part of it, I need to set learning rate to 0.0001 and potentially run up to 100 iterations (or epochs). Additionally, the batch size should be 16 and image size as 128. I will require some assistance drafting the necessary code. Would you be able to help me in this regard?", "oracle": "Pix2Pix \n Unpaired Image-to-Image Translation with Conditional Adversarial Networks \n Authors \n Phillip Isola, Jun-Yan Zhu, Tinghui Zhou, Alexei A. Efros \n Abstract \n We investigate conditional adversarial networks as a general-purpose solution to image-to-image translation problems. These networks not only learn the mapping from input image to output image, but also learn a loss function to train this mapping. This makes it possible to apply the same generic approach to problems that traditionally would require very different loss formulations. We demonstrate that this approach is effective at synthesizing photos from label maps, reconstructing objects from edge maps, and colorizing images, among other tasks. Indeed, since the release of the pix2pix software associated with this paper, a large number of internet users (many of them artists) have posted their own experiments with our system, further demonstrating its wide applicability and ease of adoption without the need for parameter tweaking. As a community, we no longer hand-engineer our mapping functions, and this work suggests we can achieve reasonable results without hand-engineering our loss functions either. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_pix2pix_dataset.sh facades \n $ cd ../implementations/pix2pix/ \n $ python3 pix2pix.py --dataset_name facades", "type": "Bash Script", "id": 17, "prefix_code": "$ cd data/ \n$ bash download_pix2pix_dataset.sh facades", "output": "python3 pix2pix.py --dataset_name facades --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 23, "path": "./implementations/cyclegan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'CycleGAN'}", "instruction": "I am looking to utilize the CycleGAN model for my task. Currently, I aim to set my learning rate to 0.0001 and want to run it over 100 training epochs. Not to forget, I also want to handle 16 examples in each batch (batch size is 16) and the images should be resized or adjusted to a size of 128. Could you please assist me in writing the code necessary to execute this?", "oracle": "CycleGAN \n Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks \n Authors \n Jun-Yan Zhu, Taesung Park, Phillip Isola, Alexei A. Efros \n Abstract \n Image-to-image translation is a class of vision and graphics problems where the goal is to learn the mapping between an input image and an output image using a training set of aligned image pairs. However, for many tasks, paired training data will not be available. We present an approach for learning to translate an image from a source domain X to a target domain Y in the absence of paired examples. Our goal is to learn a mapping G:X\u2192Y such that the distribution of images from G(X) is indistinguishable from the distribution Y using an adversarial loss. Because this mapping is highly under-constrained, we couple it with an inverse mapping F:Y\u2192X and introduce a cycle consistency loss to push F(G(X))\u2248X (and vice versa). Qualitative results are presented on several tasks where paired training data does not exist, including collection style transfer, object transfiguration, season transfer, photo enhancement, etc. Quantitative comparisons against several prior methods demonstrate the superiority of our approach. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_cyclegan_dataset.sh monet2photo \n $ cd ../implementations/cyclegan/ \n $ python3 cyclegan.py --dataset_name monet2photo", "type": "Bash Script", "id": 19, "prefix_code": "$ cd data/ \n$ bash download_cyclegan_dataset.sh monet2photo", "output": "python3 cyclegan.py --dataset_name monet2photo --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 24, "path": "./implementations/srgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'srgan'}", "instruction": "I'm trying to work with a Super-Resolution GAN model. During this, I need to set the learning rate to 0.0001 and keep the number of training epochs to 100. Also, I need to fix my batch size to 16 and the image size to 128 during the process. Could you help me compile a suitable code for completing this task?", "oracle": "Super-Resolution GAN \n Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network \n Authors \n Christian Ledig, Lucas Theis, Ferenc Huszar, Jose Caballero, Andrew Cunningham, Alejandro Acosta, Andrew Aitken, Alykhan Tejani, Johannes Totz, Zehan Wang, Wenzhe Shi \n Abstract \n Despite the breakthroughs in accuracy and speed of single image super-resolution using faster and deeper convolutional neural networks, one central problem remains largely unsolved: how do we recover the finer texture details when we super-resolve at large upscaling factors? The behavior of optimization-based super-resolution methods is principally driven by the choice of the objective function. Recent work has largely focused on minimizing the mean squared reconstruction error. The resulting estimates have high peak signal-to-noise ratios, but they are often lacking high-frequency details and are perceptually unsatisfying in the sense that they fail to match the fidelity expected at the higher resolution. In this paper, we present SRGAN, a generative adversarial network (GAN) for image super-resolution (SR). To our knowledge, it is the first framework capable of inferring photo-realistic natural images for 4x upscaling factors. To achieve this, we propose a perceptual loss function which consists of an adversarial loss and a content loss. The adversarial loss pushes our solution to the natural image manifold using a discriminator network that is trained to differentiate between the super-resolved images and original photo-realistic images. In addition, we use a content loss motivated by perceptual similarity instead of similarity in pixel space. Our deep residual network is able to recover photo-realistic textures from heavily downsampled images on public benchmarks. An extensive mean-opinion-score (MOS) test shows hugely significant gains in perceptual quality using SRGAN. The MOS scores obtained with SRGAN are closer to those of the original high-resolution images than to those obtained with any state-of-the-art method. \n [Paper] [Code] \n Run Example \n $ cd implementations/srgan/ \n <follow steps at the top of srgan.py> \n $ python3 srgan.py", "type": "Bash Script", "id": 21, "prefix_code": "", "output": "python3 srgan.py --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 25, "path": "./implementations/munit/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'model': 'MUNIT'}", "instruction": "I am considering the usage of the MUNIT model for my task. The learning rate needs to be adjusted to 0.0001 and I am looking forward to training the model for 100 epochs. Then, the batch size should be 16 and the image size should be set at 128. Can you aid me in constructing the required code for the same?", "oracle": "MUNIT  \n Multimodal Unsupervised Image-to-Image Translation  \n Authors  \n Xun Huang, Ming-Yu Liu, Serge Belongie, Jan Kautz  \n Abstract  \n Unsupervised image-to-image translation is an important and challenging problem in computer vision. Given an image in the source domain, the goal is to learn the conditional distribution of corresponding images in the target domain, without seeing any pairs of corresponding images. While this conditional distribution is inherently multimodal, existing approaches make an overly simplified assumption, modeling it as a deterministic one-to-one mapping. As a result, they fail to generate diverse outputs from a given source domain image. To address this limitation, we propose a Multimodal Unsupervised Image-to-image Translation (MUNIT) framework. We assume that the image representation can be decomposed into a content code that is domain-invariant, and a style code that captures domain-specific properties. To translate an image to another domain, we recombine its content code with a random style code sampled from the style space of the target domain. We analyze the proposed framework and establish several theoretical results. Extensive experiments with comparisons to the state-of-the-art approaches further demonstrates the advantage of the proposed framework. Moreover, our framework allows users to control the style of translation outputs by providing an example style image. Code and pretrained models are available at this https URL  \n [Paper] [Code]  \n Run Example  \n $ cd data/  \n $ bash download_pix2pix_dataset.sh edges2shoes  \n $ cd ../implementations/munit/  \n $ python3 munit.py --dataset_name edges2shoes", "type": "Bash Script", "id": 26, "prefix_code": "$ cd data/ \n$ bash download_pix2pix_dataset.sh edges2shoes", "output": "python3 munit.py --dataset_name edges2shoes --lr 0.0001 --n_epochs 100 --batch_size 16"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 26, "path": "./implementations/cluster_gan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'clustergan'}", "instruction": "Looking to use the Cluster GAN model to a project I'm working on. Hoping to set up a learning rate of 0.0001 and plan on running it for 100 epochs. I would like the batch size to be 16 and to keep image size at 128. Can you help me craft some code?", "oracle": "Cluster GAN \n ClusterGAN: Latent Space Clustering in Generative Adversarial Networks \n Authors \n Sudipto Mukherjee, Himanshu Asnani, Eugene Lin, Sreeram Kannan \n Abstract \n Generative Adversarial networks (GANs) have obtained remarkable success in many unsupervised learning tasks and unarguably, clustering is an important unsupervised learning problem. While one can potentially exploit the latent-space back-projection in GANs to cluster, we demonstrate that the cluster structure is not retained in the GAN latent space. In this paper, we propose ClusterGAN as a new mechanism for clustering using GANs. By sampling latent variables from a mixture of one-hot encoded variables and continuous latent variables, coupled with an inverse network (which projects the data to the latent space) trained jointly with a clustering specific loss, we are able to achieve clustering in the latent space. Our results show a remarkable phenomenon that GANs can preserve latent space interpolation across categories, even though the discriminator is never exposed to such vectors. We compare our results with various clustering baselines and demonstrate superior performance on both synthetic and real datasets. \n [Paper] [Code] \n Code based on a full PyTorch [implementation]. \n Run Example \n $ cd implementations/cluster_gan/ \n $ python3 clustergan.py", "type": "Bash Script", "id": 28, "prefix_code": "", "output": "python3 clustergan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 27, "path": "./implementations/aae/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'aae'}", "instruction": "I'd like to make use of an Adversarial Autoencoder model, and accordingly, I would want to set the learning rate to 0.0001. Also, I am planning to set 100 as the number of training epochs, while the batch size would be 16. To top it off, I intend to keep the image size at 128. I need your assistance with drafting the required code, could you help me out?", "oracle": "Adversarial Autoencoder \n Adversarial Autoencoder \n Authors \n Alireza Makhzani, Jonathon Shlens, Navdeep Jaitly, Ian Goodfellow, Brendan Frey \n Abstract \n n this paper, we propose the \"adversarial autoencoder\" (AAE), which is a probabilistic autoencoder that uses the recently proposed generative adversarial networks (GAN) to perform variational inference by matching the aggregated posterior of the hidden code vector of the autoencoder with an arbitrary prior distribution. Matching the aggregated posterior to the prior ensures that generating from any part of prior space results in meaningful samples. As a result, the decoder of the adversarial autoencoder learns a deep generative model that maps the imposed prior to the data distribution. We show how the adversarial autoencoder can be used in applications such as semi-supervised classification, disentangling style and content of images, unsupervised clustering, dimensionality reduction and data visualization. We performed experiments on MNIST, Street View House Numbers and Toronto Face datasets and show that adversarial autoencoders achieve competitive results in generative modeling and semi-supervised classification tasks. \n [Paper] [Code] \n Run Example \n $ cd implementations/aae/ \n $ python3 aae.py", "type": "Bash Script", "id": 29, "prefix_code": "", "output": "python3 aae.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 28, "path": "./implementations/context_encoder/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'context_encoder'}", "instruction": "For code execution, I want to utilize the Context Encoder model. For this endeavour, I propose a learning rate set to 0.0001 with the number of training epochs fixed at 100. Also, the computational batch size should be altered to 16 and dimension of images set to 128. Could you offer me any assistance in generating the associated code for it?", "oracle": "Context Encoder \n Context Encoders: Feature Learning by Inpainting \n Authors \n Deepak Pathak, Philipp Krahenbuhl, Jeff Donahue, Trevor Darrell, Alexei A. Efros \n Abstract \n We present an unsupervised visual feature learning algorithm driven by context-based pixel prediction. By analogy with auto-encoders, we propose Context Encoders -- a convolutional neural network trained to generate the contents of an arbitrary image region conditioned on its surroundings. In order to succeed at this task, context encoders need to both understand the content of the entire image, as well as produce a plausible hypothesis for the missing part(s). When training context encoders, we have experimented with both a standard pixel-wise reconstruction loss, as well as a reconstruction plus an adversarial loss. The latter produces much sharper results because it can better handle multiple modes in the output. We found that a context encoder learns a representation that captures not just appearance but also the semantics of visual structures. We quantitatively demonstrate the effectiveness of our learned features for CNN pre-training on classification, detection, and segmentation tasks. Furthermore, context encoders can be used for semantic inpainting tasks, either stand-alone or as initialization for non-parametric methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/context_encoder/ \n <follow steps at the top of context_encoder.py> \n $ python3 context_encoder.py", "type": "Bash Script", "id": 30, "prefix_code": "", "output": "python3 context_encoder.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 29, "path": "./implementations/gan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'GAN'}", "instruction": "I am planning to leverage the capabilities of a Generative Adversarial Network (GAN) for my project. A learning rate of 0.0001 is what I intend to set, along with training the model for 100 epochs. Additionally, I require the batch size to be set to as much as 16 and the image size to be conditioned to 128. Could you help me with the generation of a compatible code based on these specifications?", "oracle": "GAN \n Generative Adversarial Network \n Authors \n Ian J. Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, Yoshua Bengio \n Abstract \n We propose a new framework for estimating generative models via an adversarial process, in which we simultaneously train two models: a generative model G that captures the data distribution, and a discriminative model D that estimates the probability that a sample came from the training data rather than G. The training procedure for G is to maximize the probability of D making a mistake. This framework corresponds to a minimax two-player game. In the space of arbitrary functions G and D, a unique solution exists, with G recovering the training data distribution and D equal to 1/2 everywhere. In the case where G and D are defined by multilayer perceptrons, the entire system can be trained with backpropagation. There is no need for any Markov chains or unrolled approximate inference networks during either training or generation of samples. Experiments demonstrate the potential of the framework through qualitative and quantitative evaluation of the generated samples. \n [Paper] [Code] \n Run Example \n $ cd implementations/gan/ \n $ python3 gan.py", "type": "Bash Script", "id": 31, "prefix_code": "", "output": "python3 gan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 30, "path": "./implementations/ccgan/", "arguments": "{'lr': '0.0001', 'n_epochs': '100', 'batch_size': '16', 'img_size': '128', 'model': 'ccgan'}", "instruction": "I am looking to code a Context-Conditional GAN. The learning rate should be set to 0.0001 and the number of training epochs to 100. Set the batch size to 16 and the image size to 128. Can you assist me in creating this written code?", "oracle": "Context-Conditional GAN \n Semi-Supervised Learning with Context-Conditional Generative Adversarial Networks \n Authors \n Emily Denton, Sam Gross, Rob Fergus \n Abstract \n We introduce a simple semi-supervised learning approach for images based on in-painting using an adversarial loss. Images with random patches removed are presented to a generator whose task is to fill in the hole, based on the surrounding pixels. The in-painted images are then presented to a discriminator network that judges if they are real (unaltered training images) or not. This task acts as a regularizer for standard supervised training of the discriminator. Using our approach we are able to directly train large VGG-style networks in a semi-supervised fashion. We evaluate on STL-10 and PASCAL datasets, where our approach obtains performance comparable or superior to existing methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/ccgan/ \n $ python3 ccgan.py", "type": "Bash Script", "id": 32, "prefix_code": "", "output": "python3 ccgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 1, "path": "./", "arguments": "{'arguments1': 'caption', 'argument2': 'image'}", "instruction": "There is a task in front of me currently, which is the Image Captioning task. I ask for your kind help in moving forward with this task.", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 61, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, _ = load_model_and_preprocess(name='blip_caption', model_type='base_coco', is_eval=True, device=device)\n\nraw_image = Image.open('image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\noutput = model.generate({'image': preprocessed_image})\n\ncaption = output['captions'][0]['text']\nprint(caption)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 2, "path": "./", "arguments": "{'img_path': 'self.jpg', 'argument2': 'caption'}", "instruction": "I've got a photo labeled 'self.jpg' and I'm interested in creating a description for it. Could you give me a hand to generate a fitting caption?", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 62, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\nmodel, vis_processors, _ = load_model_and_preprocess(name='blip_caption', model_type='base_coco', is_eval=True)\n\nimage_path = 'self.jpg'\nimage = Image.open(image_path).convert('RGB')\npreprocessed_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\ninput_data = {'image': preprocessed_image}\ncaption = model.generate(input_data)\n\ncaption"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 3, "path": "./", "arguments": "{'argument1': 'vqa', 'argument': 'load_model_and_preprocess'}", "instruction": "Can you provide me with guidance on the process for executing the Visual Question Answering (VQA) task successfully? I'm requesting your assistance in figuring out the steps.", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 63, "prefix_code": "", "output": "from PIL import Image\nimport torch\nfrom lavis.models import load_model_and_preprocess\n\n# Load model and preprocess module\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='blip_vqa', model_type='vqav2', is_eval=True, device=torch.device('cuda:1' if torch.cuda.is_available() else 'cpu'))\n\n# Preprocess raw_image\nraw_image = Image.open('your_image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(model.device)\n\n# Set the question\nquestion = 'What is in the image?'\n\n# Process the question with txt_processors\nprocessed_question = txt_processors['eval'](question)\n\n# Generate caption with predict_answers method\ninference_method = 'generate'\ninput_data = {'image': preprocessed_image, 'text_input': processed_question}\ncaption = model.predict_answers(input_data, inference_method)\n\nprint(caption)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 4, "path": "./", "arguments": "{'img_path': 'my_city.jpg', 'argument': 'load_model_and_preprocess'}", "instruction": "I have a picture labeled as 'my_city.jpg', could you help to identify which city it has captured?", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 64, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\nname = 'blip_vqa'\nmodel_type = 'vqav2'\nis_eval = True\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=name, model_type=model_type, is_eval=is_eval, device=device)\n\nraw_image = Image.open('my_city.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\nquestion = 'Which city is showcased in the photographed titled my_city.jpg?'\nprocessed_question = txt_processors(['eval'])(question)\n\ncaption = model.predict_answers({'image': preprocessed_image, 'text_input': processed_question, 'inference_method': 'generate'})\ncity = caption['output'].split(':')[-1].strip()\n\nprint(city)\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 5, "path": "./", "arguments": "{'model': 'albef_vqa', 'type': 'vqav2', 'argument1': 'cat'}", "instruction": "Given an image, I am interested in highlighting what lies in front of the cat. For performing this task, I suggest using the 'albef_vqa' model and applying the 'vqav2' type. Would you be able to demonstrate how to do this?", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 65, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\n\n# Load model and preprocess module\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_vqa',\n  model_type='vqav2',\n  is_eval=True,\n  device=torch.device('cuda:1' if torch.cuda.is_available() else 'cpu'))\n\n# Preprocess raw image\nraw_image = Image.open('your_image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval']([raw_image]).unsqueeze(0).to(device)\n\n# Set question\nquestion = 'What is situated in front of the cat in the image?'\n\n# Process question\nprocessed_question = txt_processors['eval'](question)\n\n# Generate caption using model's predict_answers method\ninput_data = {'image': preprocessed_image, 'text_input': processed_question, 'inference_method': 'generate'}\ncaption = model.predict_answers(input_data)\n\n# Print the generated caption\nprint(caption)\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 6, "path": "./", "arguments": "{'img_path': './image/example.jpg', 'argument': 'load_model_and_preprocess', 'argument1': 'person'}", "instruction": "I'm interested in determining the identity of the individual pictured in the image located at './image/example.jpg'. I would like to utilize the 'albef_vqa' model for this endeavor. Can you provide me with the necessary code to accomplish this?", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 66, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Load model and preprocess\nname = 'albef_vqa'\nmodel_type = 'vqav2'\nis_eval = True\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=name, model_type=model_type, is_eval=is_eval, device=device)\n\n# Preprocess raw image\nraw_image_path = './image/example.jpg'\nraw_image = Image.open(raw_image_path).convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\n# Set question\nquestion = 'Who is the person in the photo?'\n\n# Preprocess question\nprocessed_question = txt_processors(['eval'])(question)\n\n# Generate caption\ncaption = model.predict_answers({'image': preprocessed_image, 'text_input': processed_question, 'inference_method': 'generate'})\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 7, "path": "./", "arguments": "{'type': 'vqav2', 'img_path': './image/example.jpg', 'argument1': 'who'}", "instruction": "I need to identify the individual present in the photograph located at './image/example.jpg'. To do this, I plan to use the 'albef_vqa' model that employs the 'vqav2' type. Can you help me generate some code to successfully accomplish this task?", "oracle": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 67, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Load the model and preprocess modules\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_vqa', model_type='vqav2')\n\n# Preprocess the raw image\nraw_image_path = './image/example.jpg'\nimage = Image.open(raw_image_path).convert('RGB')\npreprocessed_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Set the question\nquestion = 'Who appears in the photograph?'\n\n# Preprocess the question\nprocessed_question = txt_processors(['eval'])(question)\n\n# Generate caption using the model\ninput_data = {'image': preprocessed_image, 'text_input': processed_question}\ncaption = model.predict_answers(input_data, inference_method='generate')\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 8, "path": "./", "arguments": "{'img_path': './data/wait_for_check', 'argument1': 'bedroom', 'argument2': 'living room'}", "instruction": "I need assistance in identifying if the jpg images stored in './data/wait_for_check' represent living rooms or bedrooms. Could you assist me in distinguishing between these categories?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 68, "prefix_code": "", "output": "import torch\nfrom PIL import Image\n\nfrom lavis.models import load_model_and_preprocess\n\nname = 'albef_feature_extractor'\nmodel_type = 'base'\nis_eval = True\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=name, model_type=model_type, is_eval=is_eval)\n\nraw_image = Image.open('./data/wait_for_check/image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval']([raw_image]).unsqueeze(0).to(device)\n\ncls_names = ['living room', 'bedroom']\n\nsample = {'image': preprocessed_image, 'text_input': cls_names}\n\nimage_features = model.extract_features(sample, mode='image').image_embeds_proj[:, 0]\ntext_features = model.extract_features(sample, mode='text').text_embeds_proj[:, 0]\n\nsims = (image_features @ text_features.t())[0] / model.temp\nprobs = torch.nn.Softmax(dim=0)(sims).tolist()\n\nfor cls_nm, prob in zip(cls_names, probs):\n    print(f'{cls_nm}: \\t {prob:.3%}')"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 10, "path": "./", "arguments": "{'img_path': 'my.jpg', 'argument1': 'dog', 'argument2': 'cat'}", "instruction": "I am in possession of an image file dubbed 'my.jpg'. This could potentially fall into either the 'cat' or 'dog' category. Could you possibly guide me on the next course of action?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 70, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\nname = 'albef_feature_extractor'\nmodel_type = 'base'\nis_eval = True\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=name, model_type=model_type, is_eval=is_eval)\n\nraw_image = Image.open('my.jpg')\n\nvis_processed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\ncls_names = ['cat', 'dog']\n\nsample = {\n    'image': vis_processed_image,\n    'text_input': txt_processors(['eval'])(cls_names),\n}\n\nimage_features = model.extract_features(sample, mode='image').image_embeds_proj[:, 0]\ntext_features = model.extract_features(sample, mode='text').text_embeds_proj[:, 0]\n\nsims = (image_features @ text_features.t())[0] / model.temp\nprobs = torch.nn.Softmax(dim=0)(sims).tolist()\n\nfor cls_nm, prob in zip(cls_names, probs):\n    print(f'{cls_nm}: \\t {prob:.3%}')"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 11, "path": "./", "arguments": "{'model': 'blip', 'type': 'coco', 'img_path': 'example.jpg', 'argument1': 'match', 'argument2': 'apple'}", "instruction": "I am intriqued to see if a blip model, particularly one with a coco type, is capable of performing the image text matching task. If so, I need to evaluate the similarity score between an image named 'example.jpg' and the text 'an apple on a desk'. Can you guide me with preparing the required code?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 71, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, txt_processors = load_model_and_preprocess('blip2_image_text_matching', 'coco', device=device, is_eval=True)\n# Preprocess the image and caption\nraw_image = Image.open('example.jpg').convert('RGB').convert('RGB')\nimg = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\ntxt = txt_processors['eval']('an apple on a desk')\n\n# Calculate the similarity score\nitc_score = model({'image': img, 'text_input': txt}, match_head='itc')\nprint('The image feature and text feature have a cosine similarity of %.4f' % itc_score)\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 12, "path": "./", "arguments": "{'img_path': 'image.jpg', 'argument1': 'cat'}", "instruction": "I'm trying to identify the exact location of a cat within a given image titled 'image.jpg'. Can you support me by showcasing how to retrieve this information?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 72, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.common.gradcam import getAttMap\nfrom lavis.models.blip_models.blip_image_text_matching import compute_gradcam\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n# Load the model and preprocess data\ndef load_model_and_preprocess(name='blip_image_text_matching', model_type='base', is_eval=True):\n    device = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n    # Your model loading and preprocessing code here\n    return model, vis_processors, text_processors\n\n# Resize the raw image\ndef resize_image(raw_image, dst_w=720):\n    w, h = raw_image.size\n    scaling_factor = dst_w / w\n    resized_img = raw_image.resize((int(w * scaling_factor), int(h * scaling_factor)))\n    return resized_img\n\n# Load and resize the image\nraw_image = Image.open('image.jpg')\nresized_img = resize_image(raw_image)\n\n# Normalize the resized image\nnorm_img = np.float32(resized_img) / 255\n\n# Preprocess the image and caption\nimg = vis_processors['eval'].unsqueeze(0).to(device)\ntxt = text_processors['eval']\n\n# Compute GradCam\ntxt_tokens = model.tokenizer(txt, return_tensors='pt').to(device)\ngradcam, _ = compute_gradcam(model, img, txt, txt_tokens, block_num=7)\n\n# Average GradCam for the full image\navg_gradcam = getAttMap(norm_img, gradcam[0][1], blur=True)\nfig, ax = plt.subplots(1, 1, figsize=(10, 10))\nax.imshow(avg_gradcam)\n\n# GradCam for each token\nnum_image = len(txt_tokens.input_ids[0]) - 2\nfig, ax = plt.subplots(num_image, 1, figsize=(15, 5 * num_image))\n\ngradcam_iter = iter(gradcam[0][2:-1])\ntoken_id_iter = iter(txt_tokens.input_ids[0][1:-1])\n\nfor i, (gradcam, token_id) in enumerate(zip(gradcam_iter, token_id_iter)):\n    word = model.tokenizer.decode([token_id])\n    gradcam_image = getAttMap(norm_img, gradcam, blur=True)\n    ax[i].imshow(gradcam_image)\n    ax[i].set_yticks([])\n    ax[i].set_xticks([])\n    ax[i].set_xlabel(word)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 13, "path": "./", "arguments": "{'img_path': './data/image.jpg', 'argument1': 'cat', 'argument2': 'dog'}", "instruction": "I require assistance in extracting information from an image. The image file './data/image.jpg' contains a dog and I need to determine if there's also a cat situated behind the dog. Could you please provide assistance with deciphering the relevant information from this image?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 73, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, txt_processors = load_model_and_preprocess('blip2_image_text_matching', 'pretrain', device=device, is_eval=True)\n\n# Preprocess the raw image\nraw_image = Image.open('./data/image.jpg').convert('RGB')\nimg = vis_processors['eval'](raw_image).unsqueeze(0).to(torch.device('cuda:1' if torch.cuda.is_available() else 'cpu'))\n\n# Set the caption\ncaption = 'a bird on a tree'\n\n# Preprocess the caption\ntxt = txt_processors['eval'](caption)\n\n# Calculate the itm score\nitm_output = model({'image': img, 'text_input': txt}, match_head='itm')\nitm_scores = torch.nn.functional.softmax(itm_output, dim=1)\nprint(f'The image and text are matched with a probability of {itm_scores[:, 1].item():.3%}')"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 14, "path": "./", "arguments": "{'model': 'blip', 'type': 'base', 'img_path': './data/image.jpg', 'argument1': 'garbage'}", "instruction": "I am seeking assistance in utilizing the 'blip' model with its base type to detect the location of waste matter in the image stored at './data/image.jpg'. Can you guide me in generating the appropriate code for this use case?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 74, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\n\nmodel, vis_processors, text_processors = load_model_and_preprocess(name=\"blip_image_text_matching\", model_type=\"base\", is_eval=True)\n\n# Load the raw image\nraw_image = Image.open('./data/image.jpg')\n\n# Resize the raw image\ndst_w = 720\nw, h = raw_image.size\nscaling_factor = dst_w / w\nresized_img = raw_image.resize((int(w * scaling_factor), int(h * scaling_factor)))\nnorm_img = np.float32(resized_img) / 255\n\n# Preprocess the image and caption\nimg = vis_processors['eval'](resized_img).unsqueeze(0).to(device)\ntxt = text_processors['eval'](caption)\n\n# Compute GradCam\ntxt_tokens = model.tokenizer(txt, return_tensors='pt').to(device)\ngradcam, _ = compute_gradcam(model, img, txt, txt_tokens, block_num=7)\n\n# Average GradCam for the full image\navg_gradcam = getAttMap(norm_img, gradcam[0][1], blur=True)\n\n# GradCam for each token\nnum_image = len(txt_tokens.input_ids[0]) - 2\nfig, ax = plt.subplots(num_image, 1, figsize=(15, 5 * num_image))\n\ngradcam_iter = iter(gradcam[0][2:-1])\ntoken_id_iter = iter(txt_tokens.input_ids[0][1:-1])\n\nfor i, (gradcam, token_id) in enumerate(zip(gradcam_iter, token_id_iter)):\n    word = model.tokenizer.decode([token_id])\n    gradcam_image = getAttMap(norm_img, gradcam, blur=True)\n    ax[i].imshow(gradcam_image)\n    ax[i].set_yticks([])\n    ax[i].set_xticks([])\n    ax[i].set_xlabel(word)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 15, "path": "./", "arguments": "{'model': 'blip2', 'type': 'coco', 'img_path': 'city.jpg'}", "instruction": "Utilize the model named \"blip2\" of the type \"coco\" to help me quantify the similarity between the provided image named 'city.jpg' and the associated text 'it is a city.' Kindly enlighten me on how to accurately determine the overall match score outputted by the computation process.", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 75, "prefix_code": "", "output": "from PIL import Image\nimport torch\nfrom lavis.models import load_model_and_preprocess\n\nname = 'blip2_image_text_matching'\nmodel_type = 'coco'\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name, model_type=model_type, device=device)\nraw_image = Image.open('city.jpg')\ncaption = 'it is a city.'\n\nimg = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\ntxt = txt_processors['eval'](caption)\n\nitm_output = model({'image': img, 'text_input': txt}, match_head='itm')\nitm_scores = torch.nn.functional.softmax(itm_output, dim=1)\nprint(f'The image and text are matched with a probability of {itm_scores[:, 1].item():.3%}')\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 16, "path": "./", "arguments": "{'model': 'blip2_t5', 'type': 'pretrain_flant5xl', 'img_path': './data/example.jpg'}", "instruction": "The task at hand involves analyzing the image located at './data/example.jpg' utilizing the 'blip2_t5' model and its 'pretrain_flant5xl' type. Please assist me in deciphering what the image contains.", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 76, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Set the device\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, _ = load_model_and_preprocess(model='blip2_t5', model_type='pretrain_flant5xl')\n\n# Read and preprocess the image\nimage_path = './data/example.jpg'\nimage = Image.open(image_path)\nraw_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Generate the caption\ncaption = model.generate({'image': raw_image})\n\n# Print the generated caption\nprint('Generated caption:', caption)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 17, "path": "./", "arguments": "{'model': 'blip2_t5', 'type': 'caption_coco_flant5xl', 'img_path': 'test.jpg'}", "instruction": "I have an image titled 'test.jpg' and I'm interested in utilizing the blip2_t5 model along with its type caption_coco_flant5xl for image recognition. Could you assist me in generating a code to identify what is in the image?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 77, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Set the device\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, _ = load_model_and_preprocess(model='blip2_t5', model_type='caption_coco_flant5xl')\n\n# Read and preprocess the image\nimage_path = 'test.jpg'\nimage = Image.open(image_path)\nraw_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Generate the caption\ncaption = model.generate({'image': raw_image})\n\n# Print the generated caption\nprint('Generated caption:', caption)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 19, "path": "./", "arguments": "{'img_path': 'image.jpg', 'argument1': 'caption'}", "instruction": "I need help with generating a text description for my picture that's saved under the filename 'image.jpg'. Can you guide me through the process?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 79, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Set the device\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, _ = load_model_and_preprocess(model='blip2_t5', model_type='pretrain_flant5xl')\n\n# Read and preprocess the image\nimage_path = 'image.jpg'\nimage = Image.open(image_path)\nraw_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Generate the caption\ncaption = model.generate({'image': raw_image})\n\n# Print the generated caption\nprint('Generated caption:', caption)"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 20, "path": "./", "arguments": "{'model': 'blip2_opt', 'type': 'pretrain_opt6.7b', 'img_path': 'image.jpg'}", "instruction": "I obtained an image with the filename 'image.jpg', and my requirement is to generate various captions utilizing the 'blip2_opt' model of type 'pretrain_opt6.7b' with the provision of nucleus sampling. Your assistance to guide me in creating the appropriate code would be enormously appreciated.", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 80, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, _ = load_model_and_preprocess(name='blip2_opt', model_type='pretrain_opt6.7b')\n\n# Read and preprocess the image\nimage_path = 'image.jpg'\nimage = Image.open(image_path).convert('RGB')\nraw_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Generate multiple captions using nucleus sampling\nnum_captions = 5\ncaptions = model.generate({'image': raw_image}, use_nucleus_sampling=True, num_captions=num_captions)\n\n# Print the generated captions\nfor i, caption in enumerate(captions):\n    print(f\"Generated caption {i+1}: {caption}\")"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 21, "path": "./", "arguments": "{'model': 'albef_classification', 'img_path': 'picture.jpg', 'argument': 'mansion'}", "instruction": "I'd like help writing a code snippet. I would like to use the model 'albef_classification' to accomplish the feature extraction from images named 'picture.jpg' and 'a mansion'. Can you kindly assist me with this task?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 81, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Preprocessing raw_image\nraw_image = Image.open('picture.jpg')\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_classification', model_type='ve')\n\nprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\n# Set the caption of the picture\ncaption = 'a mansion'\n\n# Preprocess caption using txt_processors\nprocessed_caption = txt_processors['eval'](caption)\n\n# Extract features\nfeatures_image = model.extract_features({'image': processed_image})\nfeatures_text = model.extract_features({'text_input': [processed_caption]})\n\nfeatures_multimodal = model.extract_features({'image': processed_image, 'text_input': [processed_caption]})"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 22, "path": "./", "arguments": "{'model': 'blip_nlvr', 'img_path': 'image.jpg', 'argument1': 'dwelling'}", "instruction": "I need to extract features from the image file 'image.jpg' utilizing the 'blip_nlvr' model. The object of interest inside the image is 'dwelling'. Could you assist me with drawing up the proper coding framework for this operation?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 82, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nname = 'blip_nlvr'\nmodel_type = 'nlvr'\nis_eval = True\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name, model_type=model_type, is_eval=True, device=device)\n\nraw_image = Image.open('image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\ncaption = 'dwelling'\nprocessed_caption = txt_processors['eval'](caption)\n\nsample = {'image': preprocessed_image, 'text_input': [processed_caption]}\n\nfeatures_multimodal = model.extract_features(sample)\nfeatures_image = model.extract_features(sample, mode='image')\nfeatures_text = model.extract_features(sample, mode='text')\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 23, "path": "./", "arguments": "{'model': 'albef_feature_extractor', 'img_path': './image/example.jpg', 'argument1': 'desk', 'argument2': 'bed'}", "instruction": "I have an image located at './image/example.jpg' and a text string 'a bed with a desk'. I want to leverage the albef_feature_extractor model to extract relevant features from both of these inputs. Could you please assist me in writing the necessary script for this task?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 83, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\n\n# Preprocess raw_image\nraw_image = Image.open('./image/example.jpg')\nname = 'albef_feature_extractor'\nmodel_type = 'base'\nis_eval = True\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=name, model_type=model_type, is_eval=is_eval, device=device)\n\nimage = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\ncaption = 'a bed with a desk'\nprocessed_caption = txt_processors['eval']([caption])\n\n# Extract features\nfeatures = model.extract_features({'image': image, 'text_input': processed_caption})\nfeatures_multimodal = features['image']\n\n\nNote: Make sure to replace `'./image/example.jpg'` and `'a bed with a desk'` with the actual path to your image and the desired caption, respectively."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 24, "path": "./", "arguments": "{'model': 'albef_nlvr', 'img_path': 'picture.jpg', 'argument1': 'dwelling'}", "instruction": "Invoke the albef_nlvr module to generate the features for the two images, picture.jpg and a dwelling. Can you assist in formulating the appropriate code to achieve this outcome?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 84, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_nlvr', model_type='nlvr')\n\nraw_image_1 = Image.open('picture.jpg').convert('RGB')\npreprocessed_image_1 = vis_processors['eval'](raw_image_1).unsqueeze(0).to(device)\n\ncaption = 'a dwelling'\nprocessed_caption = txt_processors['eval'](caption)\n\nfeatures_multimodal = model.extract_features(image=preprocessed_image_1, text_input=[processed_caption])\n\nfeatures_image = model.extract_features(image=preprocessed_image_1, text_input=[processed_caption], mode='image')\n\nfeatures_text = model.extract_features(image=preprocessed_image_1, text_input=[processed_caption], mode='text')\n\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 25, "path": "./", "arguments": "{'model': 'blip_caption', 'img_path': './image/example.jpg'}", "instruction": "I have a task to extract features from certain images and I want to utilize the 'blip_caption' module for this objective. Specifically, I am dealing with an image located at './image/example.jpg'. Could you guide me in the process of writing the code implementation required for this task?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Python Code", "id": 85, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Preprocess raw_image\nraw_image = './image/example.jpg'\nimage = Image.open(raw_image)\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='blip_caption', model_type='base_coco')\n\n# Set the caption\ncaption = 'a house'\n\n# Preprocess the caption for txt_processors\nprocessed_caption = txt_processors(['eval'])([caption])[0]\n\n# Extract features using model\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\ninput_data = {'image': image, 'text_input': [processed_caption]}\nfeatures = model.extract_features(input_data)\n\n# Extract multimodal features\nfeatures_multimodal = features({'image': image, 'text_input': [processed_caption]})\n\n# Extract image features\nfeatures_image = features({'image': image}, mode='image')\n\n# Extract text features\nfeatures_text = features({'text_input': [processed_caption]}, mode='text')\n\n"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 26, "path": "./", "arguments": "{'model': 'pnp-vqa', 'dataset': 'vqav2_test_eval_3b'}", "instruction": "I have a task that involves running evaluation tests on a particular model named 'pnp-vqa' using the 'vqav2_test_3b' dataset. Can you assist me in crafting the necessary code for executing this task?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Bash Script", "id": 86, "prefix_code": "", "output": "python -m torch.distributed.run --nproc_per_node=8 evaluate.py --cfg-path lavis/projects/pnp-vqa/eval/vqav2_test_eval_3b.yaml"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 27, "path": "./", "arguments": "{'model': 'blip', 'dataset': 'nocaps'}", "instruction": "I need you to evaluate the effectiveness of the 'blip' model when applied to the 'nocaps' dataset. Can you provide some assistance in achieving this?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Bash Script", "id": 87, "prefix_code": "", "output": "python -m torch.distributed.run --nproc_per_node=8 evaluate.py --cfg-path lavis/projects/blip/eval/nocaps_eval.yaml"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 28, "path": "./", "arguments": "{'model': 'albef', 'dataset': 'flickr30k'}", "instruction": "I'm aiming to conduct a training session for the 'albef' model, utilizing the 'flickr30k retrieval' as the dataset for this exercise. I'd appreciate it if you could guide me through this process.", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Bash Script", "id": 88, "prefix_code": "", "output": "python -m torch.distributed.run --nproc_per_node=8 train.py --cfg-path lavis/projects/albef/train/ret_flickr30k_ft.yaml"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 29, "path": "./", "arguments": "{'model': 'blip2', 'argument': 'flant5xl', 'dataset': 'caption_coco'}", "instruction": "I have a task that involves performing an evaluation on a dataset named 'cap coco'. For this, I intend to use the 'blip2 flant5xl' model. Can you furnish me with a bit of guidance, so I can get the job done in the correct and efficient manner?", "oracle": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future.", "type": "Bash Script", "id": 89, "prefix_code": "", "output": "python -m torch.distributed.run --nproc_per_node=8 evaluate.py --cfg-path lavis/projects/blip2/eval/caption_coco_flant5xl_eval.yaml"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 1, "path": "./", "arguments": "{'argument': 'HaloAttention', 'argument3': 'torch'}", "instruction": "I am attempting to utilize the fighting-cv framework to complete the task of adding in attention layers for HaloNet Attention Usage. Could you provide assistance in guiding me through the procedure by providing the necessitated code?", "oracle": "from model.attention.HaloAttention import HaloAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(1,512,8,8)\nhalo = HaloAttention(dim=512,\n    block_size=2,\n    halo_size=1,)\noutput=halo(input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 241, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.HaloAttention import HaloAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(1,512,8,8)\nhalo = HaloAttention(dim=512,\n    block_size=2,\n    halo_size=1,)\noutput=halo(input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 2, "path": "./", "arguments": "{'argument': 'ViP', 'argument2': 'WeightedPermuteMLP', 'argument3': 'torch'}", "instruction": "I'm planning to utilize the fighting-cv model to complete the attention layers for ViP Attention Usage. Could you provide me with some guidance on accomplishing this task?", "oracle": "from model.attention.ViP import WeightedPermuteMLP\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(64,8,8,512)\nseg_dim=8\nvip=WeightedPermuteMLP(512,seg_dim)\nout=vip(input)\nprint(out.shape)\n\n", "type": "Python Code", "id": 242, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.ViP import WeightedPermuteMLP\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(64,8,8,512)\nseg_dim=8\nvip=WeightedPermuteMLP(512,seg_dim)\nout=vip(input)\nprint(out.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 3, "path": "./", "arguments": "{'argument': 'UFOAttention', 'argument3': 'torch'}", "instruction": "I'm curious about utilizing the fighting-cv module to complete attention layers specifically for UFO Attention Usage. Could you provide some guidance on how to approach this task?", "oracle": "from model.attention.UFOAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,49,512)\n    ufo = UFOAttention(d_model=512, d_k=512, d_v=512, h=8)\n    output=ufo(input,input,input)\n    print(output.shape) #[50, 49, 512]\n    \n\n", "type": "Python Code", "id": 243, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.UFOAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,49,512)\n    ufo = UFOAttention(d_model=512, d_k=512, d_v=512, h=8)\n    output=ufo(input,input,input)\n    print(output.shape) #[50, 49, 512]\n    \n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 5, "path": "./", "arguments": "{'argument': 'MUSEAttention', 'argument3': 'torch'}", "instruction": "I'm interested in utilizing the fighting-cv library to successfully implement attention layers for the MUSE Attention Usage. Can you assist me by demonstrating the necessary steps and code?", "oracle": "from model.attention.MUSEAttention import MUSEAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\ninput=torch.randn(50,49,512)\nsa = MUSEAttention(d_model=512, d_k=512, d_v=512, h=8)\noutput=sa(input,input,input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 245, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.MUSEAttention import MUSEAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\ninput=torch.randn(50,49,512)\nsa = MUSEAttention(d_model=512, d_k=512, d_v=512, h=8)\noutput=sa(input,input,input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 6, "path": "./", "arguments": "{'argument': 'ParNetAttention', 'argument3': 'torch'}", "instruction": "I'm interested in learning to use the fighting-cv model to achieve completion of attention layers for ParNet Attention Usage. Can you assist by providing the necessary guide or advice?", "oracle": "from model.attention.ParNetAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,512,7,7)\n    pna = ParNetAttention(channel=512)\n    output=pna(input)\n    print(output.shape) #50,512,7,7\n    \n\n", "type": "Python Code", "id": 246, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.ParNetAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,512,7,7)\n    pna = ParNetAttention(channel=512)\n    output=pna(input)\n    print(output.shape) #50,512,7,7\n    \n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 7, "path": "./", "arguments": "{'argument': 'TripletAttention', 'argument3': 'torch'}", "instruction": "I am looking to exploit the capabilities of 'fighting-cv' to implement attention layers that can facilitate TripletAttention Usage. Could you assist me in drafting a guideline or walkthrough that can highlight the necessary steps?", "oracle": "from model.attention.TripletAttention import TripletAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\ninput=torch.randn(50,512,7,7)\ntriplet = TripletAttention()\noutput=triplet(input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 247, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.TripletAttention import TripletAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\ninput=torch.randn(50,512,7,7)\ntriplet = TripletAttention()\noutput=triplet(input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 8, "path": "./", "arguments": "{'argument': 'SelfAttention', 'argument2': 'ScaledDotProductAttention', 'argument3': 'torch'}", "instruction": "I am interested in leveraging the fighting-cv for implementing attention layers in Self Attention Usage. Could you guide me on how to utilize this model and overcome the task?", "oracle": "from model.attention.SelfAttention import ScaledDotProductAttention\nimport torch\n\ninput=torch.randn(50,49,512)\nsa = ScaledDotProductAttention(d_model=512, d_k=512, d_v=512, h=8)\noutput=sa(input,input,input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 248, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.SelfAttention import ScaledDotProductAttention\nimport torch\n\ninput=torch.randn(50,49,512)\nsa = ScaledDotProductAttention(d_model=512, d_k=512, d_v=512, h=8)\noutput=sa(input,input,input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 9, "path": "./", "arguments": "{'argument': 'ResidualAttention', 'argument3': 'torch'}", "instruction": "I need guidance on how to leverage the fighting-cv in the implementation of attention layers pertaining to Residual Attention Usage. Could you assist me in walking through the process by providing detailed instructions or relevant sample codes?", "oracle": "from model.attention.ResidualAttention import ResidualAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(50,512,7,7)\nresatt = ResidualAttention(channel=512,num_class=1000,la=0.2)\noutput=resatt(input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 249, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.ResidualAttention import ResidualAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(50,512,7,7)\nresatt = ResidualAttention(channel=512,num_class=1000,la=0.2)\noutput=resatt(input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 11, "path": "./", "arguments": "{'argument': 'MOATransformer', 'argument3': 'torch'}", "instruction": "I am interested in utilizing fighting-cv for the purpose of completing attention layers pertaining to MOATransformer Attention Usage. Can you please assist me by providing detailed guidelines or any sample code?", "oracle": "from model.attention.MOATransformer import MOATransformer\nimport torch\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    model = MOATransformer(\n  img_size=224,\n  patch_size=4,\n  in_chans=3,\n  num_classes=1000,\n  embed_dim=96,\n  depths=[2, 2, 6],\n  num_heads=[3, 6, 12],\n  window_size=14,\n  mlp_ratio=4.,\n  qkv_bias=True,\n  qk_scale=None,\n  drop_rate=0.0,\n  drop_path_rate=0.1,\n  ape=False,\n  patch_norm=True,\n  use_checkpoint=False\n    )\n    output=model(input)\n    print(output.shape)\n    \n", "type": "Python Code", "id": 251, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.MOATransformer import MOATransformer\nimport torch\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    model = MOATransformer(\n  img_size=224,\n  patch_size=4,\n  in_chans=3,\n  num_classes=1000,\n  embed_dim=96,\n  depths=[2, 2, 6],\n  num_heads=[3, 6, 12],\n  window_size=14,\n  mlp_ratio=4.,\n  qkv_bias=True,\n  qk_scale=None,\n  drop_rate=0.0,\n  drop_path_rate=0.1,\n  ape=False,\n  patch_norm=True,\n  use_checkpoint=False\n    )\n    output=model(input)\n    print(output.shape)\n    \n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 12, "path": "./", "arguments": "{'argument': 'ShuffleTransformer', 'argument3': 'torch'}", "instruction": "I am intrigued about implementing backbone layers for ShuffleTransformer Usage via the fighting-cv module. Could you enlighten me about the entire process?", "oracle": "from model.backbone.ShuffleTransformer import ShuffleTransformer\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    sft = ShuffleTransformer()\n    output=sft(input)\n    print(output.shape)\n\n", "type": "Python Code", "id": 252, "prefix_code": "pip install fightingcv-attention", "output": "from model.backbone.ShuffleTransformer import ShuffleTransformer\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    sft = ShuffleTransformer()\n    output=sft(input)\n    print(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 13, "path": "./", "arguments": "{'argument': 'ResNet', 'argument1': 'backbone', 'argument2': '50', 'argument3': '101', 'argument4': '152'}", "instruction": "I'm looking to utilise the tool named fighting-cv in order to complete a task which involves establishing the backbone layers for ResNeXt utilization. Can you instruct me on how to efficiently manage this and perhaps provide some relevant code?", "oracle": "from model.backbone.resnext import ResNet50,ResNet101,ResNet152\nimport torch\n\nif __name__ == '__main__':\n    input=torch.randn(50,3,224,224)\n    resnext50=ResNeXt50(1000)\n    # resnext101=ResNeXt101(1000)\n    # resnext152=ResNeXt152(1000)\n    out=resnext50(input)\n    print(out.shape)\n\n", "type": "Python Code", "id": 253, "prefix_code": "pip install fightingcv-attention", "output": "\nfrom model.backbone.resnet import ResNet50,ResNet101,ResNet152\nimport torch\nif __name__ == '__main__':\n    input=torch.randn(50,3,224,224)\n    resnet50=ResNet50(1000)\n    # resnet101=ResNet101(1000)\n    # resnet152=ResNet152(1000)\n    out=resnet50(input)\n    print(out.shape)\n\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 14, "path": "./", "arguments": "{'argument': 'HATNet', 'argument3': 'torch'}", "instruction": "I'm interested in using the fighting-cv algorithm for constructing the backbone layers of the HATNet Usage project. Can you assist me in developing suitable code for this project?", "oracle": "from model.backbone.HATNet import HATNet\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    hat = HATNet(dims=[48, 96, 240, 384], head_dim=48, expansions=[8, 8, 4, 4],\n  grid_sizes=[8, 7, 7, 1], ds_ratios=[8, 4, 2, 1], depths=[2, 2, 6, 3])\n    output=hat(input)\n    print(output.shape)\n\n", "type": "Python Code", "id": 254, "prefix_code": "pip install fightingcv-attention", "output": "from model.backbone.HATNet import HATNet\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    hat = HATNet(dims=[48, 96, 240, 384], head_dim=48, expansions=[8, 8, 4, 4],\n  grid_sizes=[8, 7, 7, 1], ds_ratios=[8, 4, 2, 1], depths=[2, 2, 6, 3])\n    output=hat(input)\n    print(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 15, "path": "./", "arguments": "{'argument': 'CoaT', 'argument3': 'torch'}", "instruction": "Could you guide me on how to utilize the fighting-cv tool to complete the backbone layers for CoaT Usage? Please provide some directions or example code for my reference.", "oracle": "from model.backbone.CoaT import CoaT\nimport torch\nfrom torch import nn\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    model = CoaT(patch_size=4, embed_dims=[152, 152, 152, 152], serial_depths=[2, 2, 2, 2], parallel_depth=6, num_heads=8, mlp_ratios=[4, 4, 4, 4])\n    output=model(input)\n    print(output.shape) # torch.Size([1, 1000])\n", "type": "Python Code", "id": 255, "prefix_code": "pip install fightingcv-attention", "output": "\nfrom model.backbone.CoaT import CoaT\nimport torch\nfrom torch import nn\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    model = CoaT(patch_size=4, embed_dims=[152, 152, 152, 152], serial_depths=[2, 2, 2, 2], parallel_depth=6, num_heads=8, mlp_ratios=[4, 4, 4, 4])\n    output=model(input)\n    print(output.shape) # torch.Size([1, 1000])\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 16, "path": "./", "arguments": "{'argument': 'MlpMixer', 'argument2': 'mlp_mixer', 'argument3': 'torch'}", "instruction": "I am interested in employing the fighting-cv library for the purpose of completing the mlp layers for MLP-Mixer Usage. Could you possibly guide me in writing the proper code for this task?", "oracle": "from model.mlp.mlp_mixer import MlpMixer\nimport torch\nmlp_mixer=MlpMixer(num_classes=1000,num_blocks=10,patch_size=10,tokens_hidden_dim=32,channels_hidden_dim=1024,tokens_mlp_dim=16,channels_mlp_dim=1024)\ninput=torch.randn(50,3,40,40)\noutput=mlp_mixer(input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 257, "prefix_code": "pip install fightingcv-attention", "output": "from model.mlp.mlp_mixer import MlpMixer\nimport torch\nmlp_mixer=MlpMixer(num_classes=1000,num_blocks=10,patch_size=10,tokens_hidden_dim=32,channels_hidden_dim=1024,tokens_mlp_dim=16,channels_mlp_dim=1024)\ninput=torch.randn(50,3,40,40)\noutput=mlp_mixer(input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 17, "path": "./", "arguments": "{'argument': 'gMLP', 'argument2': 'g_mlp', 'argument3': 'torch'}", "instruction": "I am trying to complete the task of creating mlp layers for gMLP Usage and I would like to use the fighting-cv model for this. Could you guide me through the process of utilizing this model within my code to successfully accomplish my mission?", "oracle": "from model.mlp.g_mlp import gMLP\nimport torch\n\nnum_tokens=10000\nbs=50\nlen_sen=49\nnum_layers=6\ninput=torch.randint(num_tokens,(bs,len_sen)) #bs,len_sen\ngmlp = gMLP(num_tokens=num_tokens,len_sen=len_sen,dim=512,d_ff=1024)\noutput=gmlp(input)\nprint(output.shape)\n\n", "type": "Python Code", "id": 258, "prefix_code": "pip install fightingcv-attention", "output": "from model.mlp.g_mlp import gMLP\nimport torch\n\nnum_tokens=10000\nbs=50\nlen_sen=49\nnum_layers=6\ninput=torch.randint(num_tokens,(bs,len_sen)) #bs,len_sen\ngmlp = gMLP(num_tokens=num_tokens,len_sen=len_sen,dim=512,d_ff=1024)\noutput=gmlp(input)\nprint(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 19, "path": "./", "arguments": "{'data': '(50,512,7,7)', 'model': 'GFNet', 'argument3': 'torch'}", "instruction": "I'm looking to work with an input in the dimension of (50, 512, 7, 7) and would like to utilize the GFNet model to execute the Attention layers, specifically through the help of the fighting cv library. Upon completion, I would prefer to save the shape of the output for further analysis. Could you kindly guide me in creating the necessary codes for this task?", "oracle": " Implemented by Wenliang Zhao (Author)\\nfrom model.attention.gfnet import GFNet\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\nx = torch.randn(1, 3, 224, 224)\\ngfnet = GFNet(embed_dim=384, img_size=224, patch_size=16, num_classes=1000)\\nout = gfnet(x)\\nprint(out.shape)\\n\\n", "type": "Python Code", "id": 261, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "from model.attention.gfnet import GFNet\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nx = torch.randn(50,512,7,7)\ngfnet = GFNet(embed_dim=384, img_size=7, patch_size=16,num_classes=1000)\nout = gfnet(x)\nprint(out.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 20, "path": "./", "arguments": "{'data': '(50,28,28,512)', 'model': 'OutlookAttention', 'argument3': 'torch'}", "instruction": "I've got a set of input data with dimensions (50, 28, 28, 512), and my goal is to utilize this in the model known as OutlookAttention. Specifically, I would like to execute Attention layers using the fighting cv library. Can you guide me in constructing the needed code to accomplish this task?", "oracle": " from model.attention.OutlookAttention import OutlookAttention\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\ninput=torch.randn(50,28,28,512)\\noutlook = OutlookAttention(dim=512)\\noutput=outlook(input)\\nprint(output.shape)\\n\\n", "type": "Python Code", "id": 262, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nfrom model.attention.OutlookAttention import OutlookAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\n# Parse arguments\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--n_epochs\", type=int, default=200, help=\"number of epochs of training\")\nparser.add_argument(\"--batch_size\", type=int, default=64, help=\"size of the batches\")\nparser.add_argument(\"--lr\", type=float, default=0.0002, help=\"adam: learning rate\")\nparser.add_argument(\"--b1\", type=float, default=0.5, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--b2\", type=float, default=0.999, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--n_cpu\", type=int, default=8, help=\"number of cpu threads to use during batch generation\")\nparser.add_argument(\"--latent_dim\", type=int, default=100, help=\"dimensionality of the latent space\")\nparser.add_argument(\"--n_classes\", type=int, default=10, help=\"number of classes for dataset\")\nparser.add_argument(\"--img_size\", type=int, default=32, help=\"size of each image dimension\")\nparser.add_argument(\"--channels\", type=int, default=1, help=\"number of image channels\")\nparser.add_argument(\"--sample_interval\", type=int, default=400, help=\"interval between image sampling\")\nopt = parser.parse_args()\n\n# Define input data\ninput_data = torch.randn(50, 28, 28, 512)\n\n# Create OutlookAttention model\noutlook = OutlookAttention(dim=512)\n\n# Forward pass\noutput = outlook(input_data)\n\n# Print output shape\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 22, "path": "./", "arguments": "{'data': '(50,49,512)', 'model': 'SimplifiedSelfAttention', 'argument': 'SimplifiedScaledDotProductAttention', 'argument3': 'torch'}", "instruction": "I've got a dataset with size (50,49,512), and I'm planning to utilize the SimplifiedSelfAttention model to implement Attention layers through the fighting cv library. Could you assist me in composing the applicable code?", "oracle": " from model.attention.SimplifiedSelfAttention import SimplifiedScaledDotProductAttention\\nimport torch\\n\\ninput=torch.randn(50,49,512)\\nssa = SimplifiedScaledDotProductAttention(d_model=512, h=8)\\noutput=ssa(input,input,input)\\nprint(output.shape)\\n\\n", "type": "Python Code", "id": 264, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nimport torch\nfrom model.attention.SimplifiedSelfAttention import SimplifiedScaledDotProductAttention\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--n_epochs\", type=int, default=200, help=\"number of epochs of training\")\nparser.add_argument(\"--batch_size\", type=int, default=64, help=\"size of the batches\")\nparser.add_argument(\"--lr\", type=float, default=0.0002, help=\"adam: learning rate\")\nparser.add_argument(\"--b1\", type=float, default=0.5, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--b2\", type=float, default=0.999, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--n_cpu\", type=int, default=8, help=\"number of cpu threads to use during batch generation\")\nparser.add_argument(\"--latent_dim\", type=int, default=100, help=\"dimensionality of the latent space\")\nparser.add_argument(\"--n_classes\", type=int, default=10, help=\"number of classes for dataset\")\nparser.add_argument(\"--img_size\", type=int, default=32, help=\"size of each image dimension\")\nparser.add_argument(\"--channels\", type=int, default=1, help=\"number of image channels\")\nparser.add_argument(\"--sample_interval\", type=int, default=400, help=\"interval between image sampling\")\nopt = parser.parse_args()\n\ninput=torch.randn(50,49,512)\nssa = SimplifiedScaledDotProductAttention(d_model=512, h=8)\noutput=ssa(input,input,input)\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 23, "path": "./", "arguments": "{'data': '(50,512,7,7)', 'model': 'ShuffleAttention', 'argument3': 'torch'}", "instruction": "I possess an input data of size (50,512,7,7), and I'm looking to engage it in the Shuffle Attention Usage model, completing Attention layers utilizing the fighting CV library. Could you possibly guide me through the process of drafting the relevant code?", "oracle": " from model.attention.ShuffleAttention import ShuffleAttention\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\ninput=torch.randn(50,512,7,7)\\nse = ShuffleAttention(channel=512,G=8)\\noutput=se(input)\\nprint(output.shape)\\n\\n    \\n\\n", "type": "Python Code", "id": 265, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "from model.attention.ShuffleAttention import ShuffleAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput_size = (50,512,7,7)\nse = ShuffleAttention(channel=512,G=8)\noutput = se(torch.randn(*input_size))\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 24, "path": "./", "arguments": "{'data': '(50,64,512)', 'model': 'AFT', 'argument3': 'torch'}", "instruction": "I have a dataset of shape: (50,64,512) and I'm trying to implement the AFT model for Attention Usage by utilizing the fighting CV library for creating Attention layers. Following that, I'm eager to determine the shape of the output. Would you be able to assist me by providing the necessary code?", "oracle": " from model.attention.AFT import AFT_FULL\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\ninput=torch.randn(50,49,512)\\naft_full = AFT_FULL(d_model=512, n=49)\\noutput=aft_full(input)\\nprint(output.shape)\\n", "type": "Python Code", "id": 266, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nimport torch\nfrom model.attention.AFT import AFT_FULL\n\n# Define the argparse parser\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--n_epochs\", type=int, default=200, help=\"number of epochs of training\")\nparser.add_argument(\"--batch_size\", type=int, default=64, help=\"size of the batches\")\nparser.add_argument(\"--lr\", type=float, default=0.0002, help=\"adam: learning rate\")\nparser.add_argument(\"--b1\", type=float, default=0.5, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--b2\", type=float, default=0.999, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--n_cpu\", type=int, default=8, help=\"number of cpu threads to use during batch generation\")\nparser.add_argument(\"--latent_dim\", type=int, default=100, help=\"dimensionality of the latent space\")\nparser.add_argument(\"--n_classes\", type=int, default=10, help=\"number of classes for dataset\")\nparser.add_argument(\"--img_size\", type=int, default=32, help=\"size of each image dimension\")\nparser.add_argument(\"--channels\", type=int, default=1, help=\"number of image channels\")\nparser.add_argument(\"--sample_interval\", type=int, default=400, help=\"interval between image sampling\")\n\n# Parse the arguments\nopt = parser.parse_args()\n\n# Create the input tensor\ninput = torch.randn(50, 64, 512)\n\n# Initialize the AFT_FULL model\naft_full = AFT_FULL(d_model=512, n=64)\n\n# Apply AFT Attention Usage\noutput = aft_full(input)\n\n# Print the output shape\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 25, "path": "./", "arguments": "{'data': '(50,512,7,7)', 'model': 'S2Attention', 'argument3': 'torch'}", "instruction": "I am working with input data of dimension (50,512,7,7) and I wish to employ them in S2 Attention Usage to successfully execute Attention layers using the fighting cv library. Could you assist me in formulating the code needed to execute this task?", "oracle": " from model.attention.S2Attention import S2Attention\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\ninput=torch.randn(50,512,7,7)\\ns2att = S2Attention(channels=512)\\noutput=s2att(input)\\nprint(output.shape)\\n\\n", "type": "Python Code", "id": 267, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "from model.attention.S2Attention import S2Attention\nimport torch\n\ninput=torch.randn(50,512,7,7)\ns2att = S2Attention(channels=512)\noutput=s2att(input)\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 26, "path": "./", "arguments": "{'data': '(50,49,512)', 'model': 'ExternalAttention', 'argument3': 'torch'}", "instruction": "I am in possession of a data input in the shape of (50,49,512). My intention is to deploy this within the realm of External Attention Usage. My aim is to successfully complete Attention layers using the fighting cv library. However, after accomplishing this, I would also want to know the output shape. May you kindly assist in crafting the necessary coding elements?", "oracle": " from model.attention.ExternalAttention import ExternalAttention\\nimport torch\\n\\ninput=torch.randn(50,49,512)\\nea = ExternalAttention(d_model=512,S=8)\\noutput=ea(input)\\nprint(output.shape)\\n\\n", "type": "Python Code", "id": 268, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nimport torch\nfrom model.attention.ExternalAttention import ExternalAttention\n\ninput_size = (50, 49, 512)\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--d_model\", type=int, default=512, help=\"dimensionality of the model\")\nparser.add_argument(\"--S\", type=int, default=8, help=\"number of attention heads\")\nopt = parser.parse_args()\n\ninput = torch.randn(*input_size)\nea = ExternalAttention(d_model=opt.d_model, S=opt.S)\noutput = ea(input)\nprint(output.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 27, "path": "./", "arguments": "{'data': '(50,512,7,7)', 'model': 'CrissCross', 'argument3': 'torch'}", "instruction": "My data structure is in shape of (50, 512, 7, 7), I aim to employ it in CrissCrossAttention Attention Usage to complete the attention layers using the fighting cv library. Upon the final implementation, I seek to only have an output that represents the shape of the final output. Would you be willing to guide me in writing an appropriate code for this?", "oracle": " from model.attention.CrissCrossAttention import CrissCrossAttention\\nimport torch\\n\\nif __name__ == '__main__':\\n    input=torch.randn(3, 64, 7, 7)\\n    model = CrissCrossAttention(64)\\n    outputs = model(input)\\n    print(outputs.shape)\\n    \\n", "type": "Python Code", "id": 269, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "from model.attention.CrissCrossAttention import CrissCrossAttention\nimport torch\n\nif __name__ == '__main__':\n    input = torch.randn(50, 512, 7, 7)\n    model = CrissCrossAttention(512)\n    outputs = model(input)\n    print(outputs.shape)"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 28, "path": "./", "arguments": "{'data': '(50,28,28,512)', 'model': 'PolarizedSelfAttention', 'argument2': 'ParallelPolarizedSelfAttention', 'argument3': 'SequentialPolarizedSelfAttention'}", "instruction": "I possess an input data of size: (50,28,28,512). I want to make use of the Polarized Self-Attention model, with the intention of completing the Attention Layers task using the fighting cv library. Subsequent to this action, I would like to reveal the dimensions of the data output. Could you help me produce the necessary code to carry out these actions?", "oracle": " from model.attention.PolarizedSelfAttention import ParallelPolarizedSelfAttention,SequentialPolarizedSelfAttention\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\ninput=torch.randn(1,512,7,7)\\npsa = SequentialPolarizedSelfAttention(channel=512)\\noutput=psa(input)\\nprint(output.shape)\\n", "type": "Python Code", "id": 270, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "from model.attention.PolarizedSelfAttention import ParallelPolarizedSelfAttention, SequentialPolarizedSelfAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\n# Define the input size\ninput_size = (50, 28, 28, 512)\n\n# Reshape input to (50, 512, 28, 28)\ninput = torch.randn(input_size).permute(0, 3, 1, 2)\n\n# Initialize the Polarized Self-Attention layer\npsa = SequentialPolarizedSelfAttention(channel=512)\n\n# Apply the Polarized Self-Attention layer to the input\noutput = psa(input)\n\n# Print the shape of the output\nprint(output.shape)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 1, "path": "./", "arguments": "{'model': 'IF-I-L-v1.0', 'argument1': '5.0', 'argument2': 'owl', 'argument3': 'rainbow'}", "instruction": "I am intending to generate three rainbow owl images using the provided IF-I-L-v1.0 model. The 'guidance_scale' parameter should be set to 5.0 for this operation. Could you aid me in composing the required instructions to run this operation?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 91, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-L-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nif_I_kwargs = {'guidance_scale': 5.0, 'sample_timestep_respacing': 'smart100'}\nprompt = ['Rainbow owl image'] * 3\n\nresult = dream(t5, if_I, if_II, if_III, prompt=prompt, seed=42, if_I_kwargs=if_I_kwargs)\n\nresult"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 2, "path": "./", "arguments": "{'model': 'IF-II-M-v1.0', 'argument1': 'cat'}", "instruction": "I have a creative aspiration to draw a fascinating pair of felines using the outstanding IF-II-M-v1.0 model. Could you provide assistance and guide me in producing this digital illustration?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 92, "prefix_code": "", "output": "from deepfloyd_if import pipelines\nfrom deepfloyd_if.modules import IFStageI, T5Embedder\n\ndevice='cuda:1'\n\nt5 = T5Embedder(device='cuda:1')\nif_I = IFStageI('IF-II-M-v1.0', device=device)\n\nprompt = [\n    \"Draw a dynamic duo of cats\",\n    \"The cats should be playful and energetic\",\n]\n\nif_II_kwargs = {\n    'guidance_scale': 4.0,\n    'sample_timestep_respacing': 'smart50',\n}\n\nresult = pipelines.dream(\n    t5=t5,\n    if_I=if_I,\n    if_II=if_II,\n    prompt=prompt,\n    if_I_kwargs=None,\n    if_II_kwargs=if_II_kwargs,\n    if_III_kwargs=None,\n    seed=None\n)\n\nresult"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 3, "path": "./", "arguments": "{'model': 'IF-II-L-v1.0', 'argument1': '5.0'}", "instruction": "Could you assist me in generating four visuals of dogs utilizing the IF-II-L-v1.0 model? I'd like the 'guidance_scale' parameter to be adjusted to 5.0. Provide me with the necessary code, if possible.", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 93, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageII\nimport torch\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_II_kwargs = {'guidance_scale': 5.0, 'sample_timestep_respacing': 'smart50'}\n\nprompt = [\"Draw a picture of a dog.\"] * 4\n\nresult = if_II.dream(t5=None, if_I=None, if_II=if_II, if_III=None, prompt=prompt, seed=0, if_I_kwargs=None, if_II_kwargs=if_II_kwargs, if_III_kwargs=None)\n\nfor i, image_tensor in enumerate(result['II']):\n    image_tensor = image_tensor.to(device)\n    if_II.show({'II': image_tensor}, size=100)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 5, "path": "./", "arguments": "{'model': 'IF-I-L-v1.0', 'argument1': 'owl', 'argument2': 'sample_timestep_respacing', 'argument3': 'smart100'}", "instruction": "The task at hand is to create three rainbow owl images. For this objective, I'd like to employ the IF-I-L-v1.0 model. Do remember to adjust the 'sample_timestep_respacing' and set it to 'smart100'. Could you assist me in writing code that would help me achieve this?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 95, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-L-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nprompt = [\"Generate a rainbow owl image\",\"Generate another rainbow owl image\",\"Generate a third rainbow owl image\"]\n\nif_I_kwargs = {'guidance_scale': 7.0, 'sample_timestep_respacing': 'smart100'}\nif_II_kwargs = {'guidance_scale': 4.0, 'sample_timestep_respacing': 'smart50'}\nif_III_kwargs = {'guidance_scale': 9.0, 'noise_level': 20, 'sample_timestep_respacing': '75'}\n\nresult = if_III.dream(t5, if_I, if_II, if_III, prompt=prompt, seed=42, if_I_kwargs=if_I_kwargs, if_II_kwargs=if_II_kwargs, if_III_kwargs=if_III_kwargs)\n\nresult"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 6, "path": "./", "arguments": "{'model': 'IF-II-L-v1.0', 'argument1': 'dog', 'argument2': '5.0'}", "instruction": "I have an exciting artistic venture in mind, aiming to paint the essence of four canines on my canvas. I've decided to employ the remarkable IF-II-L-v1.0 model, and I plan on adjusting the 'guidance_scale' within 'nif_I_kwargs' to curate the perfect painting. Could you guide me about how to implement this?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 96, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nnif_I_kwargs = {'guidance_scale': 5.0, 'sample_timestep_respacing': 'smart100'}\nresult = pipelines.dream(t5=t5, if_I=if_I, if_II=if_II, if_III=if_III, prompt=[\"A picture of a dog\", \"A painting of a cute puppy\", \"A colorful portrait of a dog\", \"An artistic representation of a loyal canine\"], seed=123, if_I_kwargs=nif_I_kwargs)\n\nif_III.show(result['III'], size=50)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 9, "path": "./", "arguments": "{'model': 'IF-I-M-v1.0', 'argument1': 'oil', 'argument2': 'smart100'}", "instruction": "I am currently occupied with an idea that involves the creation of three notably captivating rainbow oils. To transform this idea into a reality, I find it essential to utilize the magnificent capabilities of the IF-I-M-v1.0 model. The 'sample_timestep_respacing' parameter found within the 'nif_II_kwargs' ought to be carefully adjusted to the 'smart100' setting.", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 99, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\nfrom deepfloyd_if import pipelines\n\ndevice = 'cuda:1'\n\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nif_I_kwargs = {'guidance_scale': 7.0, 'sample_timestep_respacing': 'smart100'}\nif_II_kwargs = {'guidance_scale': 4.0, 'sample_timestep_respacing': 'smart100'}\nif_III_kwargs = {'guidance_scale': 9.0, 'noise_level': 20, 'sample_timestep_respacing': '75'}\n\nprompt = [\"I've got a vision for three mesmerizing rainbow oils.\"]\nseed = 12345\n\nresult = pipelines.dream(t5=t5, if_I=if_I, if_II=if_II, if_III=if_III, prompt=prompt, seed=seed, if_I_kwargs=if_I_kwargs, if_II_kwargs=if_II_kwargs, if_III_kwargs=if_III_kwargs)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 11, "path": "./", "arguments": "{'model': 'IF-I-M-v1.0', 'argument1': 'image.jpg', 'argument2': 'cartoon'}", "instruction": "There's an image named 'image'.jpg that I'd like to enhance. Could you guide me through the process of rendering it in an animated cartoon style using the IF-I-M-v1.0 model? I anticipate this will infuse it with an energetic and lively look.", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 101, "prefix_code": "", "output": "from deepfloyd_if.pipelines import style_transfer\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\ndevice='cuda:1'\n\nimage_path = 'image.jpg'\nstyle_prompt = \"a lively cartoon style\"\nseed = 123\n\nresult = style_transfer(t5=t5, if_I=IFStageI('IF-I-M-v1.0', device=device),                if_II=if_II, support_pil_img=None, original_style_img=image_path,               style_prompt=style_prompt, seed=seed,                if_I_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0',                              'support_noise_less_qsample_steps': 5},               if_II_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50',                              'support_noise_less_qsample_steps': 5})\n\nif_I.show(result['II'], 1, 20)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 14, "path": "./", "arguments": "{'model': 'IF-II-M-v1.0', 'img_path': './data/pic.jpg', 'argument2': 'magic', 'argument3': 'cartoon'}", "instruction": "I have an image located at './data/pic.jpg' and I want to use the IF-II-M-v1.0 model to transform it into an engaging and vibrant cartoon style. Could you provide me with the appropriate coding instructions?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 104, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\noriginal_style_img = './data/pic.jpg'\nstyle_prompt = \"a captivating cartoon style\"\nseed = 42\n\nresult = if_I.style_transfer(\n    t5,\n    if_I,\n    if_II,\n    support_pil_img=original_style_img,\n    style_prompt=style_prompt,\n    seed=seed\n)\n\nif_I.show(result['II'], 1, 20)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 15, "path": "./", "arguments": "{'model': 'IF-I-XL-v1.0', 'argument1': 'image.jpg', 'argument2': 'wash'}", "instruction": "Time to create a visual masterpiece! I am excited to recreate 'image'.jpg into a fascinating rendition of the ink wash style. I am planning to utilize the capabilities of the IF-I-XL-v1.0 model for this endeavor. Can you assist me in crafting the necessary code?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 105, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nstyle_prompt = \"a captivating ink wash style\"\nimage_path = \"image.jpg\"\n\nresult = if_I.style_transfer(t5, if_I, if_II, image_path, style_prompt, seed=0, if_I_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0', 'support_noise_less_qsample_steps': 5}, if_II_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50', 'support_noise_less_qsample_steps': 5})\n\nif_I.show(result['II'], 1, 20)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 18, "path": "./", "arguments": "{'model': 'IF-II-M-v1.0', 'img_path': 'Example.jpg', 'argument1': 'ink'}", "instruction": "Exciting times ahead! We're set to create something spectacular. I've got 'Example.jpg' that I'd love to transform into an alluring ink wash painting. For this transformation, I plan on using the innovative IF-II-M-v1.0 model technology. Would you be able to guide me through the crafting process, please?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 108, "prefix_code": "", "output": "from PIL import Image\n\nfrom deepfloyd_if.modules import T5Embedder\nt5 = T5Embedder(device='cpu')\nfrom deepfloyd_if.pipeline import style_transfer\n\n# Load the input image\n\ndevice='cuda:1'\ninput_image = Image.open('Example.jpg')\n\n# Style transfer parameters\nt5 = T5Embedder(device='cuda:1')\nif_I = IFStageI('IF-II-M-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_I_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0', 'support_noise_less_qsample_steps': 5}\nif_II_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50', 'support_noise_less_qsample_steps': 5}\n\n# Perform style transfer\nresult = style_transfer(t5, if_I, if_II, input_image, style_prompt=\"a style of enchanting ink wash\")\n\n# Display the stylized image\nif_I.show(result['II'], 1, 20)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 19, "path": "./", "arguments": "{'model': 'IF-I-M-v1.0', 'img_path': 'example.jpg', 'argument1': 'example.jpg', 'argument2': 'ink'}", "instruction": "I have a digital image titled 'example.jpg' that I hope to transform into an ink wash styled masterpiece with the IF-I-M-v1.0 model. Can you guide me to write the code to transform the image accordingly?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 109, "prefix_code": "", "output": "code:\n```\n# Set the model\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\n\n# Load and preprocess the image\noriginal_style_img = Image.open('example.jpg')\nsupport_pil_img = original_style_img.resize((512, 512))\n\n# Define the style to transfer\nstyle_prompt = 'a stunning ink wash style'\n\n# Set the parameters for if_I and if_II\nif_I_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0', 'support_noise_less_qsample_steps': 5}\nif_II_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50', 'support_noise_less_qsample_steps': 5}\n\n# Perform style transfer\nresult = style_transfer(t5, t5, if_I, if_II, support_pil_img, original_style_img, style_prompt, seed=None, if_I_kwargs=if_I_kwargs, if_II_kwargs=if_II_kwargs)\n\n# Show the result\nif_I.show(result['II'], 1, 20)\n```\n\nNote: Make sure to replace 'example.jpg' with the path to your actual image file."}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 20, "path": "./", "arguments": "{'model': 'IF-I-M-v1.0', 'img_path': 'example.jpg', 'argument1': 'ink'}", "instruction": "I need your assistance in carrying out a Super Resolution Task on an image labeled 'example.jpg' depicting a dog situated on a desk. I anticipate using the IF-I-M-v1.0 model provided by IF_II_kwags. Furthermore, I require to set the guidance_scale parameter in if_III_kwargs at 7.0. Can you support me in creating the necessary code to facilitate this?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 110, "prefix_code": "", "output": "from deepfloyd_if import pipelines\nfrom deepfloyd_if.modules import IFStageI, T5Embedder\n\ndevice='cuda:1'\n\nif __name__ == \"__main__\":\n    t5 = T5Embedder(device='cuda:1')\n    if_II = IFStageII('IF-I-M-v1.0', device=device)\n    if_III = StableStageIII('stable-diffusion-x4-upscaler', device=device, guidance_scale=7.0)\n\n    prompt = [\"I'm seeking your help for a Super Resolution Task on 'example.jpg', which features a dog on a desk.\"]\n    support_pil_img = \"example.jpg\"\n    image_scale = 4\n    image_size = 64\n\n    mid_result = pipelines.super_resolution(t5, if_II, prompt, support_pil_img, image_scale, image_size, sample_timestep_respacing='smart100', aug_level=0.5)\n\n    result = pipelines.super_resolution(t5, if_III, [''], mid_result, image_scale, image_size, sample_timestep_respacing='75', noise_level=20)\n    \n    pipelines.show_superres(\"example.jpg\", result['III'][0])"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 21, "path": "./", "arguments": "{'model': 'IF-I-XL-v1.0', 'img_path': 'example.jpg', 'argument1': 'desk', 'argument2': 'dog', 'argument3': '7.0'}", "instruction": "Here's a scenario - I'm working on a Super Resolution Task using an image \"example.jpg,\" that features a dog on a desk. The intended model to be used for this operation is IF-I-XL-v1.0 stored in a variable named IF_II_kwags. In the if_III_kwargs dictionary, I want to set the guidance_scale to 7.0. In a separate step, I'll also set the noise_level to 30. Could you help me write the necessary steps in the code sequence?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 111, "prefix_code": "", "output": "from deepfloyd_if.pipelines import super_resolution\nfrom deepfloyd_if.modules import IFStageI, T5Embedder\n\n# Step 1\nt5 = T5Embedder(device='cuda:1')\nif_II = IFStageII('IF-I-XL-v1.0', device=device)\n\nmid_result = super_resolution(t5=[t5], if_II=[if_II], prompt=[\"I'm seeking your assistance for a Super Resolution Task on 'example.jpg', featuring a dog on a desk.\"], support_pil_img=[\"example.jpg\"], image_scale=4, image_size=64, sample_timestep_respacing='smart100', aug_level=0.5)\n\n# Step 2\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\n\nresult = super_resolution(if_III=[if_III], prompt=[''], support_pil_img=[mid_result], image_scale=4, image_size=64, sample_timestep_respacing='75', noise_level=30)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 23, "path": "./", "arguments": "{'model': 'IF-I-L-v1.0', 'img_path': 'example.jpg', 'argument1': 'dog', 'argument2': '7.0', 'argument3': '30'}", "instruction": "I have an image named 'example.jpg' that shows a dog on a desk and I would like to implement a Super Resolution Task on it. My plan is to utilize the IF-I-L-v1.0 model from IF_II_kwags, set the parameter guidance_scale present in if_III_kwargs to 7.0, and adjust the noise_level to 30 during the second step. Can you guide me through this process and help me write the necessary code?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 113, "prefix_code": "", "output": "from deepfloyd_if.pipelines import super_resolution\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-L-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\n# Step 1\ndevice='cuda:1'\n\nmid_result = super_resolution(\n    t5=t5,\n    if_II=IFStageII('IF-I-L-v1.0', device=device),\n    prompt=[\"I'm seeking your assistance for a Super Resolution Task on 'example.jpg', featuring a dog on a desk.\"],\n    support_pil_img='example.jpg',\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='smart100',\n    aug_level=0.5\n)\n\n# Step 2\nresult = super_resolution(\n    if_III=StableStageIII('stable-diffusion-x4-upscaler', device=device, guidance_scale=7.0),\n    prompt=[''],\n    support_pil_img=mid_result,\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='75',\n    noise_level=30\n)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 24, "path": "./", "arguments": "{'model': 'IF-II-L-v1.0', 'argument1': 'desk', 'argument4': 'dog', 'argument2': '8.0', 'argument3': '30'}", "instruction": "I possess a jpeg image file named 'image'.jpg which features a canine situated on a desk. The plan is to process this image using the IF-II-L-v1.0 model while configuring the guidance_scale parameter to 8.0. Subsequently, I'll introduce some noise to the image apart from the original content in the second step, quantifying it to the value of 30. Could you deduce the necessary lines of code to achieve this task?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 114, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\nfrom deepfloyd_if.pipelines import super_resolution\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\n# Step 1: First super resolution step with IF-II-L-v1.0 model\nmid_result = super_resolution(\n    t5=t5,\n    if_II=if_II,\n    if_III=None,\n    prompt=[\"I'm thinking of enhancing 'image'.jpg - it's a picture of a dog on a desk.\"],\n    support_pil_img={original_image_path},\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='smart100',\n    aug_level=0.5,\n    noise_level=None\n)\n\n# Step 2: Second super resolution step with stable-diffusion-x4-upscaler model and noise\nresult = super_resolution(\n    t5=None,\n    if_II=None,\n    if_III=if_III,\n    prompt=[''],\n    support_pil_img={mid_result},\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='75',\n    aug_level=None,\n    noise_level=30\n)\n\nshow_superres({original_image_path}, {result}['III'][0])"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 25, "path": "./", "arguments": "{'img_path': './data/pic.jpg', 'arg': 'resolution'}", "instruction": "I have an image located at ./data/pic.jpg. I am seeking to improve its quality by enhancing its resolution. Could you provide me with a script that could help in achieving this goal?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 115, "prefix_code": "", "output": "from deepfloyd_if.pipelines import super_resolution\nfrom deepfloyd_if.modules import IFStageI, T5Embedder\n\nt5 = T5Embedder(device='cuda:1')\nif_II = IFStageII('IF-II-L-v1.0', device='cuda:1')\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device='cuda:1')\n\nsuper_resolution(t5=t5, if_III=if_II, prompt=[\"I'd like to enhance the picture quality of ./data/pic.jpg by increasing its resolution.\"],        support_pil_img='./data/pic.jpg', image_scale=4, image_size=64, sample_timestep_respacing='smart100',        aug_level=0.5, noise_level=20)\nmid_result = super_resolution(t5=t5, if_III=if_III, prompt=prompt, support_pil_img='mid_result', image_scale=4,                     image_size=64, sample_timestep_respacing='75', noise_level=20)\n\nresult = super_resolution(t5=t5, if_III=if_III, prompt=prompt, support_pil_img='result', image_scale=4,                  image_size=64, sample_timestep_respacing='75', noise_level=20)\n\nshow_superres('./data/pic.jpg', result['III'][0])"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 26, "path": "./", "arguments": "{'model': 'IF-II-M-v1.0', 'img_path': 'example.jpg', 'arg': 'resolution', 'argument1': 'blue', 'argument2': '7.0'}", "instruction": "I'm interested in transforming 'example.jpg', a picture that showcases a woman adorned with a blue headscarf and sweater. With this intention, I plan on incorporating the IF-II-M-v1.0 model into the flow, given its proficiency in upscale operations. I'd set the 'guidance_scale' parameter to 7.0 for this task. Can you assist in generating the appropriate code for this particular operation?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 116, "prefix_code": "", "output": "from deepfloyd_if.pipelines import super_resolution\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\noutput_dir = \"output/\"\noriginal_image = \"example.jpg\"\nguidance_scale = 7.0\n\n# First step\nmid_result = super_resolution(t5=t5, if_III=None, if_II=if_II, prompt=[\"Let's upscale 'example.jpg,' which features a lady with a blue headscarf and sweater.\"],                     support_pil_img=[original_image], image_scale=4, image_size=64, sample_timestep_respacing='smart100', aug_level=0.5)\n\n# Second step\nresult = super_resolution(t5=t5, if_III=if_III, if_II=None, prompt=[''], support_pil_img=[mid_result], image_scale=4, image_size=64,                 sample_timestep_respacing='75', noise_level=20)\n\nshow_superres(original_image, result['III'][0])"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 27, "path": "./", "arguments": "{'model': 'IF-II-M-v1.0', 'img_path': 'example.jpg', 'arg': 'resolution', 'arg2': '7.0'}", "instruction": "I have an image named 'example.jpg' that showcases a woman wearing a blue headscarf and sweater, for which I wish to improve the resolution. To accomplish this, I'd like to employ the IF-II-M-v1.0 model and adjust the guidance_scale to 7.0. Could you help me write the necessary code?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 117, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-M-v1.0', device=device, guidance_scale=7.0)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\noriginal_image_path = 'example.jpg'\nmid_result = pipelines.super_resolution(t5=t5, if_II=if_II, prompt=[\"I'd like to enhance the resolution of 'example.jpg,' which features a woman in a blue headscarf and sweater.\"], support_pil_img=original_image_path, image_scale=4, image_size=64, sample_timestep_respacing='smart100', aug_level=0.5)\nresult = pipelines.super_resolution(t5=t5, if_III=if_III, prompt=[''], support_pil_img=mid_result['III'][0], image_scale=4, image_size=64, sample_timestep_respacing='75', noise_level=20)\n\nshow_superres(original_image_path, result['III'][0])"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 28, "path": "./", "arguments": "{'model': 'IF-II-L-v1.0', 'img_path': 'image.jpg', 'arg': 'resolution', 'arg2': '7.0'}", "instruction": "I own an image named 'image.jpg,' which showcases a lady flaunting a blue headscarf and sweater. I am looking to enhance its resolution by utilizing the IF-II-L-v1.0 model with the guidance_scale parameter set at 7.0. Could you guide me in creating the appropriate code for this?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 118, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\nfrom deepfloyd_if.pipelines import super_resolution\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\n# Define the parameters\nt5_model = t5\nif_II_model = if_II\nif_III_model = if_III\nprompt = [\"Boosting the resolution of my 'image.jpg,' which features a woman in a blue headscarf and sweater. I'm using the IF-II-L-v1.0 model with guidance_scale set to 7.0.\"]\nsupport_pil_img = ['image.jpg']\nimage_scale = 4\nimage_size = 64\nsample_timestep_respacing = '75'\naug_level = 0.5\nnoise_level = 20\n\n# Call the super_resolution method twice\nmid_result = super_resolution(t5_model, if_II_model, prompt, support_pil_img, image_scale, image_size, sample_timestep_respacing, aug_level=aug_level)\nresult = super_resolution(t5_model, if_III_model, [''], mid_result, image_scale, image_size, '75', noise_level=20)"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 29, "path": "./", "arguments": "{'content': 'rainbow owl', 'pixel': '36'}", "instruction": "I would like to create a single vivid illustration of a rainbow owl rendered in a style that encompasses 36 pixels. I would appreciate it if you could guide me through creating this image.", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 119, "prefix_code": "", "output": "from deepfloyd_if.pipelines import dream\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\nprompt = [\n    'A picture of a rainbow owl'\n]\n\nseed = 123\n\nif_I_kwargs = {\n    'guidance_scale': 7.0,\n    'sample_timestep_respacing': 'smart100'\n}\n\nif_II_kwargs = {\n    'guidance_scale': 4.0,\n    'sample_timestep_respacing': 'smart50'\n}\n\nif_III_kwargs = {\n    'guidance_scale': 5.0,  # Changed guidance_scale value to 5.0\n    'noise_level': 20,\n    'sample_timestep_respacing': '75'\n}\n\nresult = dream(\n    t5='t5',\n    if_I='if_I',\n    if_II='if_II',\n    if_III='if_III',\n    prompt=prompt,\n    seed=seed,\n    if_I_kwargs=if_I_kwargs,\n    if_II_kwargs=if_II_kwargs,\n    if_III_kwargs=if_III_kwargs\n)\n\n# Showing the picture using if_III's show method with size 36 pixels\nif_III.show(result['III'], size=36)\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 30, "path": "./", "arguments": "{'argument1': 'inpaint', 'arg': 'image'}", "instruction": "I have an incomplete image that I'd like to restore using the Zero-shot Inpainting algorithm. Could you help me structure efficient Python code to handle this task?", "oracle": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n", "type": "Python Code", "id": 120, "prefix_code": "", "output": "from deepfloyd_if.pipelines import inpainting\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n# Arguments for if_I\nif_I_kwargs = {\n    'guidance_scale': 7.0,\n    'sample_timestep_respacing': '10,10,10,10,10,0,0,0,0,0',\n    'support_noise_less_qsample_steps': 0\n}\n\n# Arguments for if_II\nif_II_kwargs = {\n    'guidance_scale': 4.0,\n    'aug_level': 0.0,\n    'sample_timestep_respacing': 100\n}\n\n# Arguments for if_III\nif_III_kwargs = {\n    'guidance_scale': 9.0,\n    'noise_level': 20,\n    'sample_timestep_respacing': '75'\n}\n\n# Path to the original image\nsupport_pil_img = 'path_to_original_image.jpg'\n\n# Description of what to inpaint\nprompt = ['Fill the missing areas with appropriate content']\n\n# Random seed value\nseed = 123\n\n# Generate the inpainted image\nresult = inpainting(\n    t5='t5',\n    if_I='if_I',\n    if_II='if_II',\n    if_III='if_III',\n    prompt=prompt,\n    support_pil_img=support_pil_img,\n    inpainting_mask='inpainting_mask',\n    seed=seed,\n    if_I_kwargs=if_I_kwargs,\n    if_II_kwargs=if_II_kwargs,\n    if_III_kwargs=if_III_kwargs\n)\n\n# Show the generated images\nif_I.show(result['I'], 2, 3)\nif_I.show(result['II'], 2, 6)\nif_I.show(result['III'], 2, 14)\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 1, "path": "./", "arguments": "{'model': 'edge2face', 'dataset': 'face', 'resolusion size': '512'}", "instruction": "I'm planning to employ the model edge2face on a face dataset, realizing a resolution of 512. Can you assist in outlining the appropriate code structure?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 121, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py\npython scripts/download_flownet2.py\npython scripts/face/download_models.py", "output": "python test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 8, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '2048'}", "instruction": "I'm planning to use the label2city model and I wish to evaluate its performance on the Cityscapes dataset. I want this to be carried out at a resolution size of 2048. Can you assist me by providing the required code for the task?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 128, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py\npython scripts/download_flownet2.py\npython scripts/street/download_models.py", "output": "python test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 9, "path": "./", "arguments": "{'model': 'edge2face', 'dataset': 'face', 'resolusion size': '256', 'argument': 'g1'}", "instruction": "We have the task of training the edge2face model on a face dataset. Let's set the resolution size this time to 256. Can you provide assistance in drafting the applicable coding structure?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 129, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name edge2face_256_g1 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 256 --ngf 64 --max_frames_per_gpu 6 --n_frames_total 12 --niter 20 --niter_decay 20"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 10, "path": "./", "arguments": "{'model': 'edge2face', 'dataset': 'face', 'resolusion size': '512'}", "instruction": "I have an intriguing task that involves training the edge2face model on a face dataset. As I understand it, this dataset has a resolution size of 512. To enhance data processing, I plan to set the training across 6 GPUs. Could you offer me step-by-step guidance on how I should go about writing the required code for such a process?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 130, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --num_D 3 --gpu_ids 0,1,2,3,4,5 --n_gpus_gen 8 --batchSize 7 --niter 20 --niter_decay 20 --n_frames_total 12"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 20, "path": "./", "arguments": "{'model': 'pose2body', 'dataset': 'pose', 'resolusion size': '256p'}", "instruction": "I have a task to complete using the pose2body model on a pose dataset, and I need this task to utilize 4 GPUs. Additionally, the dataset must be processed at a resolution of 256p. Could you assist me in scripting the necessary code to complete this task?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 140, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name pose2body_256p --dataroot datasets/pose --dataset_mode pose --input_nc 6 --num_D 2 --resize_or_crop randomScaleHeight_and_scaledCrop --loadSize 384 --fineSize 256 --gpu_ids 0,1,2,3 --batchSize 8 --max_frames_per_gpu 3 --niter 5 --niter_decay 5 --no_first_img --n_frames_total 12 --max_t_step 4"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 21, "path": "./", "arguments": "{'model': 'pose2body', 'dataset': 'pose', 'resolusion size': '256p', 'argument': 'g1'}", "instruction": "I need assistance in training the pose2body model specifically on a single GPU. For optimization, I suggest we utilize a smaller size such as 256p for the pose dataset. This approach should enhance performance without overburdening the GPU. Could you guide me through the code necessary for this task?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 141, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name pose2body_256p_g1 --dataroot datasets/pose --dataset_mode pose --input_nc 6 --ngf 64 --num_D 2 --resize_or_crop randomScaleHeight_and_scaledCrop --loadSize 384 --fineSize 256 --niter 5 --niter_decay 5 --no_first_img --n_frames_total 12 --max_frames_per_gpu 4 --max_t_step 4"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 22, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city'}", "instruction": "I'm looking to train the label2city model using the Cityscapes dataset. Also, I'd like to experiment with adjusting the image size using the 'bs' parameter. Could you provide me in-depth guidance on balancing these parameters and give the most optimal results possible?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 142, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_512_bs --label_nc 35 --loadSize 512 --use_instance --fg --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen -1 --n_frames_total 6 --batchSize 15"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 23, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '1024', 'n_frames_total': '2', 'max_frames_per_gpu': '2', 'learning rate': '0.00001', 'argument': 'g1'}", "instruction": "I am interested in training the label2city Model on the Cityscapes dataset. The resolution size I'm working with is 1024, and I will be using a single GPU for this task. Please ensure that the maximum frames per GPU are set to 2 and the learning rate is specified to be 0.00001. Can you aid me in writing the appropriate piece of code?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 143, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_1024_g1 --label_nc 35 --loadSize 896 --n_scales_spatial 3 --n_frames_D 2 --use_instance --fg --n_downsample_G 2 --num_D 3 --max_frames_per_gpu 2 --n_frames_total 2 --niter_step 2 --niter_fix_global 8 --niter_decay 5 --load_pretrain checkpoints/label2city_512_g1 --lr 0.00001"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 24, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '512', 'max_frames_per_gpu': '1'}", "instruction": "I wish to train the label2city Model on the Cityscapes dataset. To accomplish this, I want to restrict the resolution size to 512 and constrain the maximum frames per GPU to just 1. Can you assist in creating the required code for this?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 144, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_512 --label_nc 35 --loadSize 512 --use_instance --fg --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 6 --n_frames_total 6 --max_frames_per_gpu 1"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 25, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '512'}", "instruction": "In order to improve performance, I would suggest utilizing the label2city model to conduct training on the Cityscapes dataset, with an exceptional characteristic that none of the foreground objects are to be included. Additionally, the resolution of the images used in the training should be set to a size of 512 pixels. Could you provide some code samples that could accomplish this task?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 145, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_512_no_fg --label_nc 35 --loadSize 512 --use_instance --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 6 --n_frames_total 6 --max_frames_per_gpu 2 "}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 26, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '2048_crop', 'learning rate': '0.00002'}", "instruction": "I'm interested in conducting a training process for the label2city model using the Cityscapes dataset as the bedrock of my training source. Furthermore, you could optimize the resolution size to be '2048_crop' for better results. The learning rate, an essential parameter for this training, should be fixed at 0.00002. Can you guide me to draft the appropriate programming instructions for this procedure?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 146, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_2048_crop --label_nc 35 --loadSize 2048 --fineSize 1024 --resize_or_crop crop --n_scales_spatial 3 --num_D 4 --use_instance --fg --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 4 --n_frames_total 4 --niter_step 1 --niter 5 --niter_decay 5 --niter_fix_global 5 --load_pretrain checkpoints/label2city_1024 --lr 0.00002"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 27, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '2048'}", "instruction": "Implementing a task of model training using the label2city model on the Cityscapes dataset, we should target a high resolution size, such as 2048 pixels. Can you guide me in formulating the necessary script?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 147, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --num_D 4 --use_instance --fg --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 4 --n_frames_total 4 --niter_step 1 --niter 5 --niter_decay 5 --niter_fix_global 5 --load_pretrain checkpoints/label2city_1024 --lr 0.00005"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 28, "path": "./", "arguments": "{'model': 'label2city', 'dataset': 'city', 'resolusion size': '512', 'argument': 'g1'}", "instruction": "For purposes of maintaining a fine blend of performance and efficiency, I would like to train the label2city model on a singular GPU. The dataset I would be training on is the Cityscapes dataset and the preferred resolution size is 512 pixels. Can you provide me with requisite instructions?", "oracle": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n", "type": "Bash Script", "id": 148, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_512_g1 --label_nc 35 --loadSize 512 --n_scales_spatial 2  --use_instance --fg --n_downsample_G 2 --max_frames_per_gpu 2 --n_frames_total 4 --niter_step 2 --niter_fix_global 8 --niter_decay 5 --load_pretrain checkpoints/label2city_256_g1"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 1, "path": "./", "arguments": "{'model': 'coca_ViT-B-32', 'argument2': 'coca_ViT-B-32', 'argument3': 'mscoco_finetuned_laion2b-s13b-b90k', 'argument4': 'cat.jpg'}", "instruction": "I have an image with the name cat.jpg, and I am interested in using the coca_ViT-B-32 model and the mscoco_finetuned_laion2b_s13b_b90k pre-training model to generate text description. Can you guide me through this process and provide necessary sample code?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 181, "prefix_code": "", "output": "import open_clip\nimport torch\nmodel, _, transform = open_clip.create_model_and_transforms(\n  model_name='coca_ViT-B-32',\n   pretrained='mscoco_finetuned_laion2B-s13B-b90k'\n)\nfrom PIL import Image\nfrom PIL import Image\nim = Image.open('cat.jpg').convert('RGB')\nim = transform(im).unsqueeze(0)\nwith torch.no_grad(), torch.cuda.amp.autocast():\n  generated = model.generate(im)\nprint(open_clip.decode(generated[0]).split('<end_of_text>')[0].replace('<start_of_text>', ''))"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 18, "path": "./", "arguments": "{'model': 'ViT-B-32', 'argument2': 'ViT-B-32', 'argument3': 'commonpool_s_laion_s13m_b4k', 'argument4': './image'}", "instruction": "I'm hoping you could assist me with a task. I need to sort a collection of images located at the directory '. /image'. For this purpose, I'll be using the 'ViT-B-32' model along with the pretraining model 'commonpool_s_laion_s13m_b4k'. Would you be able to provide instructions or steps on how to accomplish this task?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 198, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='commonpool_s_laion_s13m_b4k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 20, "path": "./", "arguments": "{'model': 'convnext_large_d', 'argument2': 'convnext_large_d'}", "instruction": "I'm looking to use the model convnext_large_d for sorting a series of images. Could you please assist me in creating the necessary code for this task?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 200, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('convnext_large_d', pretrained='laion2b_s26b_b102k_augreg')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 21, "path": "./", "arguments": "{'model': 'ViT-B-32-quickgelu', 'argument2': 'ViT-B-32-quickgelu', 'argument3': 'openai', 'argument4': './usr/image', 'argument5': \"plane': 'A plane is flying in the blue sky'\", 'cat': 'A grey and white cat'}", "instruction": "I need assistance in categorizing these image files using the ViT-B-32-quickgelu model. In addition, the openai pretraining model will be utilized. The path of the pictures is ./usr/image and they are described as follows: the image 'plane' depicts a plane flying in a blue sky and the 'cat' image shows a grey and white cat. Can you guide me in writing the required code?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 201, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32-quickgelu', pretrained='openai')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 22, "path": "./", "arguments": "{'model': 'convnext_xxlarge', 'argument2': 'convnext_xxlarge', 'argument3': 'laion2b_s34b_b82k_augreg_rewind', 'argument4': './usr/image', 'argument5': 'A cat was driving on the road', 'dog': 'A brown dog was lying on the ground'}", "instruction": "My goal is to organize a set of images using the convnext_xxlargemodel and Pretraining laion2b_s34b_b82k_augreg_rewind module. The images can be found at this path: './usr/image'. Also, here is a brief description of the images I'm working with:", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 202, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('convnext_xxlarge', pretrained='laion2b_s34b_b82k_augreg_rewind')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'A cat was driving on the road',\n    'dog': 'A brown dog was lying on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 24, "path": "./", "arguments": "{'model': 'convnext_base', 'argument2': 'convnext_base', 'argument3': 'laion400m_s13b_b51k'}", "instruction": "I'm in need of your assistance to arrange these images. I'm considering leveraging two specific tools for this operation, the 'convnext_base' model and the 'Pretraining laion400m_s13b_b51k' model. Could you aid me in writing the scripting required to accomplish this?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 196, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('convnext_base', pretrained='laion400m_s13b_b51k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 25, "path": "./", "arguments": "{'model': 'ViT-B-32', 'argument2': 'ViT-B-32', 'argument3': 'commonpool_s_text_s13m_b4k', 'argument4': './usr/image'}", "instruction": "I need assistance in organizing a sequence of images located at ./usr/image. Is it possible for you to guide me through the process of sorting these images by making use of the ViT-B-32 model that is based on Pretraining model - commonpool_s_text_s13m_b4k? Looking forward to your helpful insight.", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 205, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='commonpool_s_text_s13m_b4k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 27, "path": "./", "arguments": "{'model': 'EVA02-L-14', 'argument2': 'EVA02-L-14', 'argument3': 'merged2b_s4b_b131k', 'argument4': './usr/image', 'argument5': 'A cat was driving on the road', 'dog': 'A brown dog was lying on the ground'}", "instruction": "I have a range of images that require sorting using the EVA02-L-14 model alongside the merged2b_s4b_b131k model for Pretraining purposes. The path for these images is ./usr/image, and attached descriptions include: {'cat': 'A cat was driving on the road'}, {'dog': 'A brown dog was lying on the ground'}. Could you assist me by drafting appropriate code for the task?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 207, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('EVA02-L-14', pretrained='merged2b_s4b_b131k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'A cat was driving on the road',\n    'dog': 'A brown dog was lying on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 28, "path": "./", "arguments": "{'model': 'ViT-g-14', 'argument2': 'ViT-g-14', 'argument3': 'laion2b_s34b_b88k'}", "instruction": "I seek assistance in order to array these images by deploying the ViT-g-14 model in conjunction with the Pretraining model laion2b_s34b_b88k. Could you lend a hand by providing a comprehensive code chunk, which could enable me to get this task underway?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 208, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-g-14', pretrained='laion2b_s34b_b88k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'There is a cat moving on the road', 'dog': 'A brown dog is resting on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 29, "path": "./", "arguments": "{'model': 'RN101', 'argument2': 'RN101', 'argument3': 'yfcc15m', 'argument4': './usr/image'}", "instruction": "I require your assistance in arranging some images. I intend to utilize the RN101 model along with the Pretraining model yfcc15m for this task. The location of the pictures is ./usr/image. Could you kindly assist me in formulating the appropriate code?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 209, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('RN101', pretrained='yfcc15m')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 30, "path": "./", "arguments": "{'model': 'ViT-B-16', 'argument2': 'ViT-B-16', 'argument3': 'laion2b_s34b_b88k'}", "instruction": "I need your help in organizing some images I have. The model I wish to utilize for this task is ViT-B-16, and I also want to implement the Pretraining model laion2b_s34b_b88k. Can you guide me through writing the required code for this endeavor?", "oracle": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory.", "type": "Python Code", "id": 210, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-16', pretrained='laion2b_s34b_b88k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'There is a cat moving on the road', 'dog': 'A brown dog is resting on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 1, "path": "./", "arguments": "{'task_name': 'classification', 'model': 'FEDformer', 'data': 'UEA', 'model_id': 'FaceDetection', 'patience': '10', 'batch_size': '16', 'train_epochs': '100'}", "instruction": "I'm aiming to conduct a performance evaluation of my FEDformer model which is designated for a classification task. I would like to utilize subset: FaceDetection of the UEA benchmark dataset for this evaluation. The patience parameter needs to be set to 10, with the train epochs set to 16, and batch size adjusted to 100. Could you kindly provide me the code necessary to accomplish this?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 211, "prefix_code": "", "output": "python -u run.py \\\n  --task_name classification \\\n  --is_training 1 \\\n  --root_path ./dataset/FaceDetection/ \\\n  --model_id FaceDetection \\\n  --model FEDformer \\\n  --data UEA \\\n  --e_layers 3 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 256 \\\n  --top_k 3 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --train_epochs 100 \\\n  --patience 10"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 2, "path": "./", "arguments": "{'task_name': 'classification', 'model': 'MICN', 'data': 'UEA', 'model_id': 'SpokenArabicDigits', 'patience': '10', 'batch_size': '16', 'train_epochs': '100'}", "instruction": "For my classification task, I aim to evaluate the performance of my specified model - MICN. I plan to use the SpokenArabicDigits subset from the UEA benchmark dataset. I will set the patience to 10, train epochs to 16, and the batch size to 100. Is it possible for you to aid me in drawing up the necessary code?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 212, "prefix_code": "", "output": "python -u run.py \\\n  --task_name classification \\\n  --is_training 1 \\\n  --root_path ./dataset/SpokenArabicDigits/ \\\n  --model_id SpokenArabicDigits \\\n  --model MICN \\\n  --data UEA \\\n  --e_layers 3 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 256 \\\n  --top_k 3 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --train_epochs 100 \\\n  --patience 10"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 3, "path": "./", "arguments": "{'task_name': 'classification', 'model': 'LightTS', 'data': 'UEA', 'model_id': 'PEMS'}", "instruction": "I'm in need of conducting a performance assessment for my task, which is model classification. The model I'm using for this task is named LightTS. The specific benchmark dataset that I'm intending to work with is from UEA, particularly the subset named PEMS. Could you assist me by writing the appropriate code for this task?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 213, "prefix_code": "", "output": "python -u run.py \\\n  --task_name classification \\\n  --is_training 1 \\\n  --root_path ./dataset/PEMS-SF/ \\\n  --model_id PEMS-SF \\\n  --model LightTS \\\n  --data UEA \\\n  --e_layers 3 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 256 \\\n  --top_k 3 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --train_epochs 100 \\\n  --patience 10"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 4, "path": "./", "arguments": "{'task_name': 'classification', 'model': 'MICN', 'data': 'UEA', 'model_id': 'EthanolConcentration', 'patience': '10', 'batch_size': '16', 'train_epochs': '100'}", "instruction": "I have a classification task that I aim to perform utilizing the MICN model. In my project, I would like to ascertain its performance using the EthanolConcentration subset, which is part of the benchmark datasets from UEA. I'd like to set up, too, patience parameter to 10 time steps, along with assigning training epochs to 16 and the batch size to 100. Would you mind assisting me in writing this code?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 214, "prefix_code": "", "output": "python -u run.py \\\n  --task_name classification \\\n  --is_training 1 \\\n  --root_path ./dataset/EthanolConcentration/ \\\n  --model_id EthanolConcentration \\\n  --model MICN \\\n  --data UEA \\\n  --e_layers 3 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 256 \\\n  --top_k 3 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --train_epochs 100 \\\n  --c_out 3 \\\n  --patience 10"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 18, "path": "./", "arguments": "{'task_name': 'long_term_forecast', 'model': 'Crossformer', 'data': 'traffic', 'pred_len': '720'}", "instruction": "I am intending to execute a performance assessment of my Crossformer model for a long term forecast task. The benchmark dataset I'd like to utilize is Traffic, and I wish to set the pred_len to 720. Could you please assist me in crafting the required programming code?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 228, "prefix_code": "", "output": "python -u run.py \\\n  --task_name long_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/traffic/ \\\n  --data_path traffic.csv \\\n  --model_id traffic_96_720 \\\n  --model Crossformer \\\n  --data custom \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 96 \\\n  --pred_len 720 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 862 \\\n  --dec_in 862 \\\n  --c_out 862 \\\n  --top_k 5 \\\n  --des 'Exp' \\\n  --n_heads 2 \\\n  --batch_size 4 \\\n  --itr 1"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 19, "path": "./", "arguments": "{'task_name': 'long_term_forecast', 'model': 'MICN', 'data': 'weather', 'pred_len': '720'}", "instruction": "I am preparing to conduct a performance evaluation of a model I've developed specifically for a long term forecast task. The model, named MICN, necessitates the application of a benchmark dataset. I've chosen to use Weather for this purpose. Additionally, the prediction length is fixed at 720. I implore your expertise to aid me in authoring the necessary code.", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 229, "prefix_code": "", "output": "python -u run.py \\\n  --task_name long_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/weather/ \\\n  --data_path weather.csv \\\n  --model_id weather_96_720 \\\n  --model MICN \\\n  --data custom \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 96 \\\n  --pred_len 720 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 21 \\\n  --dec_in 21 \\\n  --c_out 21 \\\n  --d_model 32 \\\n  --d_ff 32 \\\n  --top_k 5 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --train_epochs 1"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 20, "path": "./", "arguments": "{'task_name': 'anomaly_detection', 'model': 'Crossformer', 'data': 'MSL'}", "instruction": "I am attempting to use Crossformer model for the specific task of anomaly detection. MSL is the benchmark dataset that I will need to employ for this endeavor. Could you possibly assist me in the formulation of the necessary code segments to evaluate the performance of this model?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 230, "prefix_code": "", "output": "python -u run.py \\\n  --task_name anomaly_detection \\\n  --is_training 1 \\\n  --root_path ./dataset/MSL \\\n  --model_id MSL \\\n  --model Crossformer \\\n  --data MSL \\\n  --features M \\\n  --seq_len 100 \\\n  --pred_len 0 \\\n  --d_model 128 \\\n  --d_ff 128 \\\n  --e_layers 3 \\\n  --enc_in 55 \\\n  --c_out 55 \\\n  --anomaly_ratio 1 \\\n  --batch_size 128 \\\n  --train_epochs 10"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 21, "path": "./", "arguments": "{'task_name': 'anomaly_detection', 'model': 'Autoformer', 'data': 'SMAP', 'anomaly_ratio': '1', 'batch_size': '128', 'train_epochs': '3'}", "instruction": "I am looking to run a performance test on my anomaly detection task, employing the Autoformer model for the same. The benchmark dataset I intend to use for this purpose is SMAP, and I need to have an anomaly ratio defined as 1. Additionally, setup the environment to support a train epoch value of 128 and a batch size of 3. Can you guide me towards creating some valuable code for this task setup?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 231, "prefix_code": "", "output": "python -u run.py \\\n  --task_name anomaly_detection \\\n  --is_training 1 \\\n  --root_path ./dataset/SMAP \\\n  --model_id SMAP \\\n  --model Autoformer \\\n  --data SMAP \\\n  --features M \\\n  --seq_len 100 \\\n  --pred_len 0 \\\n  --d_model 128 \\\n  --d_ff 128 \\\n  --e_layers 3 \\\n  --enc_in 25 \\\n  --c_out 25 \\\n  --anomaly_ratio 1 \\\n  --batch_size 128 \\\n  --train_epochs 3"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 23, "path": "./", "arguments": "{'task_name': 'short_term_forecast', 'model': 'FEDformer', 'data': 'm4', 'seasonal_patterns': 'Weekly', 'root_path': './dataset/m4'}", "instruction": "I'm looking to carry out a performance analysis on my FEDformer model specifically for the short term forecast task. I have selected M4 as the benchmark dataset, with the seasonal patterns set to 'Weekly'. Considering that the root_path is './dataset/m4' and there is no assigned data path, can you assist me in drafting the appropriate code?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 233, "prefix_code": "", "output": "python -u run.py \\\n  --task_name short_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/m4 \\\n  --seasonal_patterns 'Weekly' \\\n  --model_id m4_Weekly \\\n  --model FEDformer \\\n  --data m4 \\\n  --features M \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 1 \\\n  --dec_in 1 \\\n  --c_out 1 \\\n  --batch_size 16 \\\n  --d_model 512 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --loss 'SMAPE'"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 24, "path": "./", "arguments": "{'task_name': 'short_term_forecast', 'model': 'Crossformer', 'data': 'm4', 'seasonal_patterns': 'Daily'}", "instruction": "Can you assist me in writing some code? I'm dealing with a short-term forecast task and I would like to evaluate the performance of my model, which is the Crossformer. I have decided to use the M4 benchmark dataset and I would like to set the seasonal patterns to Daily.", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 234, "prefix_code": "", "output": "python -u run.py \\\n  --task_name short_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/m4 \\\n  --seasonal_patterns 'Daily' \\\n  --model_id m4_Daily \\\n  --model Crossformer \\\n  --data m4 \\\n  --features M \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 1 \\\n  --dec_in 1 \\\n  --c_out 1 \\\n  --batch_size 16 \\\n  --d_model 16 \\\n  --d_ff 16 \\\n  --top_k 5 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --loss 'SMAPE'"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 25, "path": "./", "arguments": "{'task_name': 'short_term_forecast', 'model': 'Informer', 'data': 'm4', 'seasonal_patterns': 'Hourly'}", "instruction": "I have a task at hand that requires me to evaluate the performance of my model, specifically, the Informer model, for a short term forecast setup. The dataset that I have opted for use in this task is the M4, with the seasonal patterns set to Hourly. I would be really grateful if you can assist me in writing the supporting code for this task.", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 235, "prefix_code": "", "output": "python -u run.py \\\n  --task_name short_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/m4 \\\n  --seasonal_patterns 'Hourly' \\\n  --model_id m4_Hourly \\\n  --model Informer \\\n  --data m4 \\\n  --features M \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 1 \\\n  --dec_in 1 \\\n  --c_out 1 \\\n  --batch_size 16 \\\n  --d_model 512 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --loss 'SMAPE'\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 26, "path": "./", "arguments": "{'task_name': 'imputation', 'model': 'ETSformer', 'data': 'ecl', 'mask_rate': '0.375', 'learning_rate': '0.001'}", "instruction": "I'm seeking assistance in executing a performance evaluation for my ETSformer model, based on an imputation task. The dataset of choice for this benchmark task is ECL and it provides a base mask rate of 0.375. Let's proceed with a learning rate of 0.001. I'd appreciate it if you could aid me in drafting the necessary code.", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 236, "prefix_code": "", "output": "python -u run.py \\\n  --task_name imputation \\\n  --is_training 1 \\\n  --root_path ./dataset/electricity/ \\\n  --data_path electricity.csv \\\n  --model_id ECL_mask_0.375 \\\n  --mask_rate 0.375 \\\n  --model ETSformer \\\n  --data custom \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 0 \\\n  --pred_len 0 \\\n  --e_layers 2 \\\n  --d_layers 2 \\\n  --factor 3 \\\n  --enc_in 321 \\\n  --dec_in 321 \\\n  --c_out 321 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 128 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --top_k 5 \\\n  --learning_rate 0.001"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 27, "path": "./", "arguments": "{'task_name': 'imputation', 'model': 'Transformer', 'data': 'ETTm1', 'mask_rate': '0.25'}", "instruction": "The job at hand involves conducting an evaluation of a Transformer model performance intended for an imputation task. For this process, I would be using the subset: ETTm1 from the benchmark: ETT. During this process, please ensure the mask rate is set to 0.25. Your assistance is required in generating the appropriate code to facilitate this?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 237, "prefix_code": "", "output": "python -u run.py \\\n  --task_name imputation \\\n  --is_training 1 \\\n  --root_path ./dataset/ETT-small/ \\\n  --data_path ETTm1.csv \\\n  --model_id ETTm1_mask_0.25 \\\n  --mask_rate 0.25 \\\n  --model Transformer \\\n  --data ETTm1 \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 0 \\\n  --pred_len 0 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 7 \\\n  --dec_in 7 \\\n  --c_out 7 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 128 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --top_k 5 \\\n  --learning_rate 0.001"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 28, "path": "./", "arguments": "{'task_name': 'imputation', 'model': 'TimesNet', 'data': 'ETTh1', 'mask_rate': '0.375'}", "instruction": "I'm looking to evaluate the performance of my TimesNet model for an imputation task. The benchmark dataset I intend to use is the ETTh1 subset of ETT, with a mask rate of 0.375. Could you assist me by guiding me through the coding process?", "oracle": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n", "type": "Bash Script", "id": 238, "prefix_code": "", "output": "python -u run.py \\\n  --task_name imputation \\\n  --is_training 1 \\\n  --root_path ./dataset/ETT-small/ \\\n  --data_path ETTh1.csv \\\n  --model_id ETTh1_mask_0.375 \\\n  --mask_rate 0.375 \\\n  --model TimesNet \\\n  --data ETTh1 \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 0 \\\n  --pred_len 0 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 7 \\\n  --dec_in 7 \\\n  --c_out 7 \\\n  --batch_size 16 \\\n  --d_model 16 \\\n  --d_ff 32 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --top_k 3 \\\n  --learning_rate 0.001"}
{"github_id": 11, "github": "https://github.com/huggingface/pytorch-image-models", "repo_id": 1, "path": "./", "arguments": "{'model': 'swin_base_patch4_window7_224.ms_in22k_ft_in1k', 'amp-dtype': 'bfloat16', 'input-size': '3 256 320', 'window_size': '8,10', 'img_size': '256,320'}", "instruction": "I would like to perform the task of resizing the image or window. To accomplish this, I will be utilizing the swin_base_patch4_window7_224.ms_in22k_ft_in1k model. Moreover, I need to set the amp-dtype to bfloat16 and the input-size to 3 256 320. Additionally, I would like to specify the window_size as 8,10 and the img_size as 256,320. Could you kindly assist me in developing the necessary code or script for this purpose?", "oracle": "Swin, MaxViT, CoAtNet, and BEiT models support resizing of image/window size on creation with adaptation of pretrained weights Example validation cmd to test w/ non-square resize\u00a0python validate.py /imagenet --model swin_base_patch4_window7_224.ms_in22k_ft_in1k --amp --amp-dtype bfloat16 --input-size 3 256 320 --model-kwargs window_size=8,10 img_size=256,320", "type": "Bash Script", "id": 201, "prefix_code": "", "output": "python validate.py /imagenet --model swin_base_patch4_window7_224.ms_in22k_ft_in1k --amp --amp-dtype bfloat16 --input-size 3 256 320 --model-kwargs window_size=8,10 img_size=256,320"}
{"github_id": 11, "github": "https://github.com/huggingface/pytorch-image-models", "repo_id": 2, "path": "./", "arguments": "{'model': 'vit_base_patch16_224', 'amp-dtype': 'bfloat16', 'img-size': '255', 'crop-pct': '1.0', 'dynamic_img_size': 'True', 'dyamic_img_pad': 'True'}", "instruction": "I am interested in performing the task of resizing the image or window. For this purpose, I would like to utilize the model vit_base_patch16_224. Additionally, it would be helpful to set the amp-dtype to bfloat16. \nMoreover, I would like to specify the image size as 255 and the crop percentage as 1.0. To ensure flexibility, I would like to enable dynamic image size and dynamic image padding. \nCould you kindly assist me in creating the code or script to accomplish this objective?", "oracle": "Existing method of changing patch_size (resize pretrained patch_embed weights once) on creation still works.Example validation cmd python validate.py /imagenet --model vit_base_patch16_224 --amp --amp-dtype bfloat16 --img-size 255 --crop-pct 1.0 --model-kwargs dynamic_img_size=True dyamic_img_pad=True", "type": "Bash Script", "id": 202, "prefix_code": "", "output": "python validate.py /imagenet --model vit_base_patch16_224 --amp --amp-dtype bfloat16 --img-size 255 --crop-pct 1.0 --model-kwargs dynamic_img_size=True"}
{"github_id": 11, "github": "https://github.com/huggingface/pytorch-image-models", "repo_id": 3, "path": "./", "arguments": "{'model': 'convnext_small.in12k', 'label-type': 'detail', 'topk': '5'}", "instruction": "I have a task where I need to generate a CSV file containing the Top-k Class Ids for images in a specific folder. To accomplish this, I will be utilizing the convnext_small.in12k model. It is important to note that I would like the labels to be in detail format, and I want to output the top 5 class Ids. Can you kindly assist me in writing the code or script for this particular task?", "oracle": "Add ImageNetInfo / DatasetInfo classes to provide labelling for various ImageNet classifier layouts in timm Update inference.py to use, try: python inference.py /folder/to/images --model convnext_small.in12k --label-type detail --topk 5 Ready for 0.8.10 pypi pre-release (final testing).", "type": "Bash Script", "id": 203, "prefix_code": "", "output": "python inference.py /folder/to/images --model convnext_small.in12k --label-type detail --topk 5"}
{"github_id": 11, "github": "https://github.com/huggingface/pytorch-image-models", "repo_id": 4, "path": "./", "arguments": "{'model': 'resnet50', 'output_stride': '16', 'act_layer': 'silu'}", "instruction": "I am embarking on an ImageNet training endeavor and in dire need of some assistance. My desired model for this task is resnet50 with an output stride of 16. Additionally, I would like to utilize the silu activation layer. Could you kindly provide me with the necessary code or script to accomplish this? Your help would be greatly appreciated.", "oracle": "Finally got around to adding --model-kwargs and --opt-kwargs to scripts to pass through rare args directly to model classes from cmd line train.py /imagenet --model resnet50 --amp --model-kwargs output_stride=16 act_layer=silu", "type": "Bash Script", "id": 204, "prefix_code": "", "output": "python train.py /imagenet --model resnet50 --amp --model-kwargs output_stride=16 act_layer=silu"}
{"github_id": 11, "github": "https://github.com/huggingface/pytorch-image-models", "repo_id": 5, "path": "./", "arguments": "{'model': 'vit_base_patch16_clip_224', 'img-size': '240', 'img_size': '240', 'patch_size': '12'}", "instruction": "I am interested in conducting ImageNet training and have chosen the vit_base_patch16_clip_224 model for this task. To ensure optimal results, I would like to set the image size to 240 pixels and the patch size to 12. Can you please assist me in generating the necessary code or script?", "oracle": "train.py /imagenet --model vit_base_patch16_clip_224 --img-size 240 --amp --model-kwargs img_size=240 patch_size=12 Cleanup some popular models to better support arg passthrough / merge with model configs, more to go.", "type": "Bash Script", "id": 205, "prefix_code": "", "output": "python train.py /imagenet --model vit_base_patch16_clip_224 --img-size 240 --amp --model-kwargs img_size=240 patch_size=12"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 1, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'dcp', 'number of points': '512', 'number of data loading workers': '-j 8', 'symmetric function': '--symfn max'}", "instruction": "I am interested in conducting a test using the dcp model. Specifically, I would like to set the parameters as follows: the test mode should be selected, the model should be set to dcp, the number of points should be 512, the number of data loading workers should be -j 8, and the symmetric function should be set to --symfn max. Could you please assist me in writing the code or script necessary to carry out this test?", "oracle": "examples/test_dcp.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 226, "prefix_code": "", "output": "python test_dcp.py --num_points 512 -j 8 --symfn max"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 2, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'deepgmr', 'number of points': '256', 'number of data loading workers': '-j 2', 'nearest neighbors': '--nearest_neighbors 16', 'dataset type': 'shapenet2'}", "instruction": "I am interested in running a test on the deepgmr model. Specifically, I would like to set the following parameters: \n- `train_or_test` to \"test\"\n- `model` to \"deepgmr\"\n- `number of points` to 256\n- `number of data loading workers` to \"-j 2\"\n- `nearest neighbors` to \"--nearest_neighbors 16\"\n- `dataset type` to \"shapenet2\".\n\nCould you please assist me in writing the necessary code or script to execute this test?", "oracle": "examples/test_deepgmr.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 227, "prefix_code": "", "output": "python test_deepgmr.py --num_points 256 -j 8 --nearest_neighbors 16 --dataset_type shapenet2"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 3, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'flownet', 'embedding dimentions': '--emb_dims 256', 'number of points': '--num_points 1024', 'add gaussian noise': '--gaussian_noise True'}", "instruction": "I am interested in testing the flownet model. Specifically, I would like to set the 'train_or_test' parameter to 'test' and the 'model' parameter to 'flownet'. Additionally, I would like to include an embedding dimension of 256, specified by the argument '--emb_dims 256'. Moreover, I would like to have a total of 1024 points, indicated by the argument '--num_points 1024'. Lastly, I want to add Gaussian noise to the process and would appreciate if you could guide me by providing the necessary code or script.", "oracle": "examples/test_flownet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 228, "prefix_code": "", "output": "python test_flownet.py --emb_dims 256 --num_points 1024 --gaussian_noise True"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 4, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'masknet', 'number of points': '--num_points 256', 'add noise': '--noise True', 'use unseen': '--unseen True', 'use outliers': '--outliers True'}", "instruction": "I am interested in testing the masknet model using the provided arguments. Specifically, I would like to set the training or testing mode to 'test', utilize the masknet model, and have the number of points set to 256 using the flag '--num_points'. Additionally, I would like to incorporate noise in the data using the flag '--noise', consider unseen data using the flag '--unseen', and include outliers using the flag '--outliers'. Could you kindly assist me in writing the necessary code or script to accomplish this?", "oracle": "examples/test_masknet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 229, "prefix_code": "", "output": "python test_masknet.py --num_points 256 --noise True --unseen True --outliers True"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 5, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'masknet2', 'add noise': '--noise True', 'number of points': '--num_points 512', 'number of data loading workers': '-j 4', 'add outliers': '--outliers True'}", "instruction": "I am currently interested in using the \"masknet2\" model for the purpose of conducting a test. Specifically, I would like to set the following parameters: \"model.train_or_test\" to \"test\", \"add noise\" to \"--noise True\", \"number of points\" to \"--num_points 512\", \"number of data loading workers\" to \"-j 4\", and \"add outliers\" to \"--outliers True\". Could you kindly assist me in generating the code or script required to achieve this?", "oracle": "examples/test_masknet2.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 230, "prefix_code": "", "output": "python test_masknet2.py --noise True --num_points 512 -j 4 --outliers True"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 6, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'pcn', 'dataset type': '--dataset_type shapenet2', 'number of points': '--num_points 256', 'embedding dimentions': '--emb_dims 512', 'seed': '--seed 42'}", "instruction": "I am interested in performing a test using the pcn model. For this purpose, I would like to set the 'train_or_test' argument as 'test' and the 'model' argument as 'pcn'. Additionally, I need to specify the dataset type as '--dataset_type shapenet2' and the number of points as '--num_points 256'. Furthermore, it is essential to set the embedding dimensions to '--emb_dims 512' and the seed value as '--seed 42'. Could you kindly assist me by providing the code or script necessary to accomplish this task?", "oracle": "examples/test_pcn.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 231, "prefix_code": "", "output": "python test_pcn.py --dataset_type shapenet2 --num_points 256 --emb_dims 512 --seed 42"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 7, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'pcrnet', 'eval?': '--eval True', 'symmetric function': '--symfn avg', 'number of data loading workers': '-j 2', 'embedding dim': '--emb_dims 512'}", "instruction": "I am interested in running a test using the pcrnet model. Specifically, I would like to perform the test by setting the 'train_or_test' argument to 'test'. In addition, I would like to specify the model as 'pcrnet' and evaluate the results by setting the '--eval' parameter to True. For the symmetric function, I would like to use 'avg' as the option by using the argument '--symfn avg'. Furthermore, I would like to set the number of data loading workers to 2 using the argument '-j 2'. Lastly, I would like to specify the embedding dimension as 512 by utilizing the argument '--emb_dims 512'. Could you kindly assist me in generating the necessary code or script to accomplish this task?", "oracle": "examples/test_pcrnet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 232, "prefix_code": "", "output": "python test_pcrnet.py --eval True --symfn avg -j 2 --emb_dims 512"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 8, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'pnlk', 'seed': '--seed 42', 'number of points': '--num_points 512', 'batch size': '-b 2', 'embedding dim': '--emb_dims 512'}", "instruction": "I am interested in running a test on the pnlk model using the provided arguments. Specifically, I would like to set the train_or_test parameter to \"test\", the model parameter to \"pnlk\", the seed parameter to \"--seed 42\", the number of points parameter to \"--num_points 512\", the batch size parameter to \"-b 2\", and the embedding dimension parameter to \"--emb_dims 512\". Could you kindly assist me in writing the code or script required for this task?", "oracle": "examples/test_pnlk.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 233, "prefix_code": "", "output": "python test_pnlk.py --seed 42 --num_points 512 -b 2 --emb_dims 512"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 9, "path": "./examples", "arguments": "{'train_or_test': 'test', 'model': 'rpmnet', 'symmetric function': '--symfn avg', 'number of points': '--num_points 256', 'batch size': '-b 2', 'dataset type': '--dataset_type shapenet2'}", "instruction": "I am interested in performing a test using the rpmnet model. Please set the 'train_or_test' argument to 'test', and use the 'rpmnet' model for this task. Additionally, please set the symmetric function to '--symfn avg', the number of points to '--num_points 256', the batch size to '-b 2', and the dataset type to '--dataset_type shapenet2'. Could you kindly assist me in writing the code or script necessary to accomplish this?", "oracle": "examples/test_rpmnet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 234, "prefix_code": "", "output": "python test_masknet2.py --symfn avg --num_points 256 -b 2 --dataset_type shapenet2"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 10, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'PointNetLK', 'dataset type': '--dataset_type shapenet2', 'number of points': '--num_points 256', 'fine tune pointnet': '--fine_tune_pointnet fixed', 'symmetric function': '--symfn avg', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am interested in performing a training session using the PointNetLK model. Specifically, I would like to train the model by setting the 'train_or_test' argument to 'train'. Additionally, I would like to utilize the 'shapenet2' dataset type for this training. To ensure accurate results, it is crucial to represent each shape with 256 points, which can be achieved by setting the 'num_points' argument to 256. Furthermore, I would like to fine-tune the PointNet model and keep it fixed during training, so please set the 'fine_tune_pointnet' argument to 'fixed'. When calculating the symmetry function, I prefer to use the 'avg' method, hence the 'symfn' argument should be set accordingly. For embedding dimensions, I would like to set the value to 512 by specifying the 'emb_dims' argument as 512. Lastly, I would like to train the model in batches of size 16, so please set the 'batch size' argument to '-b 16'. Could you assist me by providing the necessary code or script to accomplish this task?", "oracle": "examples/train_PointNetLK.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 235, "prefix_code": "", "output": "python train_PointNetLK.py --dataset_type shapenet2 --num_points 256 --fine_tune_pointnet fixed --symfn avg --emb_dims 512 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 11, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'prnet', 'dataset type': '--dataset_type modelnet', 'number of Iterations': '--num_iterations 4', 'epochs': '--epochs 10', 'optimizer': '--optimizer SGD', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am interested in conducting a training session with the prnet model. Specifically, I would like to focus on the task of training and set the model to prnet. Furthermore, I would like to work with a dataset of type modelnet. To ensure optimal performance, I would like to run the training for a total of 4 iterations, with each iteration lasting for 10 epochs. For the optimization process, I prefer to use the SGD optimizer. Additionally, I would like to set the embedding dimensions to 512 and the batch size to 16. Could you please assist me in writing the necessary code or script to accomplish this training?", "oracle": "examples/train_prnet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 236, "prefix_code": "", "output": "python train_prnet.py --dataset_type modelnet --num_iterations 4 --epochs 10 --optimizer SGD --emb_dims 512 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 12, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'pointnet', 'dataset type': '--dataset_type shapenet2', 'number of points': '--num_points 512', 'fine tune pointnet': '--pointnet tune', 'symmetric function': '--symfn max', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am eager to engage in the development process, specifically by assisting you in writing the code or script. To achieve this, I would greatly appreciate it if you could provide the following essential arguments: \n\n1. First and foremost, we need to ascertain whether you desire to train or test the model. Kindly specify your preference by providing the argument 'train_or_test' set to 'train'. \n\n2. Additionally, we need to determine the specific model to be utilized. To this end, please provide the argument 'model' set to 'pointnet'. \n\n3. It is crucial to ascertain the dataset type. Could you kindly supply the argument '--dataset_type', with a value of 'shapenet2'? This will ensure the correct dataset is utilized. \n\n4. Furthermore, we need to specify the number of points to be employed in the model. Kindly provide the argument '--num_points' with a value of 512. \n\n5. Next, let us address the fine-tuning of PointNet. Please specify whether you would like to enable this functionality by including the argument '--pointnet' set to 'tune'. \n\n6. When it comes to the symmetric function to be used, kindly provide the argument '--symfn' set to 'max'. This will ensure the appropriate symmetric function is applied during the process. \n\n7. Ensuring the appropriate embedding dimensions is also crucial. Kindly supply the argument '--emb_dims' with a value of 512. \n\n8. Finally, we need to determine the batch size. Could you please specify the desired batch size by providing the argument '-b' set to 16? \n\nAfter considering and incorporating all of the above requirements into the code or script, we will be well-prepared to proceed further. Should you require any additional assistance or clarification, please do not hesitate to inform me.", "oracle": "examples/train_pointnet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 237, "prefix_code": "", "output": "python train_pointnet.py --dataset_type shapenet2 --num_points 512 --pointnet tune --symfn max --emb_dims 512 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 13, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'pointconv', 'epochs': '--epochs 100', 'number of points': '--num_points 256', 'fine tune pointnet': '--pointnet fixed', 'symmetric function': '--symfn max', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am interested in training the pointconv model. Specifically, I would like to train the model using the 'train' mode. To achieve this, I would like to set the following parameters: \n\n- Model: pointconv \n- Number of epochs: 100 \n- Number of points: 256 \n- Fine-tune pointnet: fixed \n- Symmetric function: max \n- Embedding dimensions: 512 \n- Batch size: 16 \n\nWould you kindly assist me in writing the code or script to accomplish this task?", "oracle": "examples/train_pointconv.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 238, "prefix_code": "", "output": "python train_pointconv.py --epochs 100 --num_points 256 --pointnet fixed --symfn max --emb_dims 512 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 14, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'prcnet', 'dataset type': '--dataset_type shapenet2', 'number of points': '--num_points 256', 'fine tune pointnet': '--pointnet tune', 'symmetric function': '--symfn avg', 'epochs': '100', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am interested in training the prcnet model. To do so, I would like to set the following arguments: \n\n- 'train_or_test' should be set to 'train'\n- 'model' should be set to 'prcnet'\n- 'dataset type' should be set to '--dataset_type shapenet2'\n- 'number of points' should be set to '--num_points 256'\n- 'fine tune pointnet' should be set to '--pointnet tune'\n- 'symmetric function' should be set to '--symfn avg'\n- 'epochs' should be set to 100\n- 'embedding dims' should be set to '--emb_dims 512'\n- 'batch size' should be set to '-b 16'\n\nCould you please assist me by providing the necessary code or script to accomplish this training task?", "oracle": "examples/train_pcrnet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 239, "prefix_code": "", "output": "python train_prcnet.py --dataset_type shapenet2 --num_points 256 --pointnet tune --symfn avg --emb_dims 512 -b 16 --epochs 100"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 15, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'pcn', 'dataset type': '--dataset_type shapenet2', 'number of points': '--num_points 256', 'detailed output': '--detailed_output True', 'epochs': '--epochs 200', 'embedding dims': '--emb_dims 512', 'batch size': '-b 16'}", "instruction": "I am interested in running a training process for the pcn model. To do this, I would like to set the train_or_test parameter to 'train' and the model parameter to 'pcn'. Additionally, I would like to use the shapenet2 dataset type by setting the dataset_type parameter to '--dataset_type shapenet2'. For better results, I would prefer to have 256 points for each data sample, so please set the number of points to '--num_points 256'. Furthermore, I would like to enable detailed output by setting the detailed_output parameter to '--detailed_output True'. To ensure thorough training, I would like to run the process for 200 epochs, so please set the epochs parameter to '--epochs 200'. Additionally, I would like to have an embedding dimensions of 512, so please set the emb_dims parameter to '--emb_dims 512'. Finally, I would like to have a batch size of 16, so please set the batch size parameter to '-b 16'. Could you help me write the necessary code or script for this task?", "oracle": "examples/train_pcn.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 240, "prefix_code": "", "output": "python train_pcnK.py --dataset_type shapenet2 --num_points 256 --detailed_output True --epochs 20 --emb_dims 512 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 16, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'masknet', 'unseen': '--unseen True', 'number of points': '--num_points 512', 'outliers': '--outliers True', 'add noise': '--noise True', 'epochs': '--epochs 200', 'batch size': '-b 16'}", "instruction": "I am interested in performing the task of training the masknet model. To achieve this, I need to set the following arguments: 'train_or_test' should be set to 'train', 'model' should be set to 'masknet', 'unseen' should be set to '--unseen True', 'number of points' should be set to '--num_points 512', 'outliers' should be set to '--outliers True', 'add noise' should be set to '--noise True', 'epochs' should be set to '--epochs 200', and 'batch size' should be set to '-b 16'. \n\nCan you assist me by writing the code or script for this task?", "oracle": "examples/train_masknet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 241, "prefix_code": "", "output": "python train_masknet.py --unseen True --num_points 512 --outliers True --noise avg --epochs 200 -b 16"}
{"github_id": 13, "github": "https://github.com/vinits5/learning3d", "repo_id": 17, "path": "./examples", "arguments": "{'train_or_test': 'train', 'model': 'flownet', 'dropout': '--dropout 0.7', 'number of points': '--num_points 256', 'learning rate': '--lr 0.01', 'momentum': '--momentum 0.8', 'add gaussian noise': '--gaussian_noise True', 'batch size': '-batch_size 8'}", "instruction": "I'd like to perform the training of the \"flownet\" model. For this task, I need to set the variable \"model.train_or_test\" to \"train\". Additionally, I would like to include a dropout of 0.7 by using \"--dropout 0.7\". To ensure a proper number of points, I will set the value of \"number of points\" to \"--num_points 256\". For optimization purposes, I will assign a learning rate of \"--lr 0.01\" and a momentum of \"--momentum 0.8\". Moreover, I would like to add gaussian noise to the data by including \"--gaussian_noise True\". Lastly, it is important to set the batch size to \"-batch_size 8\". Could you please assist me by providing the necessary code or script to execute this?", "oracle": "examples/train_flownet.py Learning3D is an open-source library that supports the development of deep learning algorithms that deal with 3D data. The Learning3D exposes a set of state of art deep neural networks in python", "type": "Bash Script", "id": 242, "prefix_code": "", "output": "python train_flownet.py --dropout 0.7 --num_points 256 --lr 0.01 --momentum 0.8 --gaussian_noise True --batch_size 8"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 1, "path": "./musicbert", "arguments": "{'bash': 'train_mask.sh', 'dataset': 'lmd_full', 'checkpoint': 'small'}", "instruction": "I am interested in performing a Pre-training task, specifically using the train_mask.sh script as the bash command. For this task, I would like to utilize the lmd_full dataset and the small checkpoint. Could you please assist me in writing the code or script required for this purpose?", "oracle": "Pre-training bash train_mask.sh lmd_full small Download our pre-trained checkpoints here: small and base, and save in the  checkpoints folder. (a newer version of fairseq is needed for using provided checkpoints: see issue-37 or issue-45)", "type": "Bash Script", "id": 243, "prefix_code": "", "output": "bash train_mask.sh lmd_full small"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 2, "path": "./musicbert", "arguments": "{'bash': 'train_mask.sh', 'dataset': 'lmd_full', 'checkpoint': 'base'}", "instruction": "I am eager to begin the task of Pre-training using the train_mask.sh script as my bash command. The dataset I will be utilizing is lmd_full, and I will be referring to the base checkpoint. Can you please provide me with the necessary code or script to accomplish this?", "oracle": "Pre-training bash train_mask.sh lmd_full small Download our pre-trained checkpoints here: small and base, and save in the  checkpoints folder. (a newer version of fairseq is needed for using provided checkpoints: see issue-37 or issue-45)", "type": "Bash Script", "id": 244, "prefix_code": "", "output": "bash train_mask.sh lmd_full base"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 3, "path": "./musicbert", "arguments": "{'bash': 'train_nsp.sh', 'task_type': 'next', 'checkpoint': 'checkpoints/checkpoint_last_musicbert_base.pt'}", "instruction": "I have a task at hand, which involves performing Fine-tuning on melody completion. To accomplish this, I need to utilize the train_nsp.sh script, specifying the task_type as 'next'. Additionally, I require the checkpoint file named 'checkpoint_last_musicbert_base.pt' located in the 'checkpoints' directory. May I solicit your assistance in developing the necessary code or script to facilitate this task?", "oracle": "2.2 Fine-tuning on melody completion task and accompaniment suggestion task bash train_nsp.sh next checkpoints/checkpoint_last_musicbert_base.pt bash train_nsp.sh acc checkpoints/checkpoint_last_musicbert_small.pt", "type": "Bash Script", "id": 245, "prefix_code": "", "output": "bash train_nsp.sh next checkpoints/checkpoint_last_musicbert_base.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 4, "path": "./musicbert", "arguments": "{'bash': 'train_nsp.sh', 'task_type': 'acc', 'checkpoint': 'checkpoints/checkpoint_last_musicbert_small.pt'}", "instruction": "I am interested in performing Fine-tuning on accompaniment suggestion. The relevant bash script for this task is train_nsp.sh. Specifically, I would like to focus on the task_type 'acc' and utilize the checkpoint located at 'checkpoints/checkpoint_last_musicbert_small.pt'. Could you kindly assist me in crafting the necessary code or script for this?", "oracle": "2.2 Fine-tuning on melody completion task and accompaniment suggestion task bash train_nsp.sh next checkpoints/checkpoint_last_musicbert_base.pt bash train_nsp.sh acc checkpoints/checkpoint_last_musicbert_small.pt", "type": "Bash Script", "id": 246, "prefix_code": "", "output": "bash train_nsp.sh acc checkpoints/checkpoint_last_musicbert_small.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 5, "path": "./musicbert", "arguments": "{'bash': 'train_genre.sh', 'task_type': 'topmagd', 'num_classes': 13, 'fold_index': 0, 'checkpoint': 'checkpoints/checkpoint_last_musicbert_base.pt'}", "instruction": "I am interested in performing Fine-tuning on the genre.bash dataset using the train_genre.sh script. Specifically, I am targeting the task_type topmagd with 13 num_classes and fold_index 0. To accomplish this, I would like to utilize the checkpoint_last_musicbert_base.pt checkpoint file. Could you kindly assist me in writing the necessary code or script to complete this task?", "oracle": "2.3 Fine-tuning on genre and style classification task bash train_genre.sh topmagd 13 0 checkpoints/checkpoint_last_musicbert_base.pt bash train_genre.sh masd 25 4 checkpoints/checkpoint_last_musicbert_small.pt", "type": "Bash Script", "id": 247, "prefix_code": "", "output": "bash train_genre.sh topmagd 13 0 checkpoints/checkpoint_last_musicbert_base.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 6, "path": "./musicbert", "arguments": "{'bash': 'train_genre.sh', 'task_type': 'masd', 'num_classes': 25, 'fold_index': 4, 'checkpoint': 'checkpoints/checkpoint_last_musicbert_small.pt'}", "instruction": "I am interested in performing Fine-tuning on style classification. The bash script that I need to use is train_genre.sh. Additionally, the task type should be set to \"masd\" and the number of classes to 25. Furthermore, I would like to specify the fold index as 4 and the checkpoint as \"checkpoints/checkpoint_last_musicbert_small.pt\". Could you kindly assist me in writing the code or script required for this task?", "oracle": "2.3 Fine-tuning on genre and style classification task bash train_genre.sh topmagd 13 0 checkpoints/checkpoint_last_musicbert_base.pt bash train_genre.sh masd 25 4 checkpoints/checkpoint_last_musicbert_small.pt", "type": "Bash Script", "id": 248, "prefix_code": "", "output": "bash train_genre.sh masd 25 4 checkpoints/checkpoint_last_musicbert_small.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 7, "path": "./musicbert", "arguments": "{'argument1': '-u', 'eval_file': 'eval_nsp.py', 'checkpoint_file': 'checkpoints/checkpoint_last_nsp_next_checkpoint_last_musicbert_base.pt', 'data_name_or_path': 'next_data_bin'}", "instruction": "I am seeking assistance in developing a code or script for the purpose of Melody completion and accompaniment suggestion. The required arguments for this task are as follows: \n- argument1: -u \n- eval_file: eval_nsp.py \n- checkpoint_file: checkpoints/checkpoint_last_nsp_next_checkpoint_last_musicbert_base.pt \n- data_name_or_path: next_data_bin \n\nWould you kindly provide me with the necessary code or script to accomplish this objective?", "oracle": "3.1 Melody completion task and accompaniment suggestion task python -u eval_nsp.py checkpoints/checkpoint_last_nsp_next_checkpoint_last_musicbert_base.pt next_data_bin", "type": "Bash Script", "id": 249, "prefix_code": "", "output": "python -u eval_nsp.py checkpoints/checkpoint_last_nsp_next_checkpoint_last_musicbert_base.pt next_data_bin"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 8, "path": "./musicbert", "arguments": "{'argument1': '-u', 'eval_file': 'eval_genre.py', 'checkpoint_file': 'checkpoints/checkpoint_last_genre_topmagd_x_checkpoint_last_musicbert_small.pt', 'data_name_or_path': 'topmagd_data_bin/x'}", "instruction": "I am looking to perform Genre and style classification using the provided arguments. The value of argument1 should be set to \"-u\", the eval_file should be \"eval_genre.py\", the checkpoint_file should be \"checkpoints/checkpoint_last_genre_topmagd_x_checkpoint_last_musicbert_small.pt\", and the data_name_or_path should be \"topmagd_data_bin/x\". I require your assistance in writing the code or script for this task.", "oracle": "3.2 Genre and style classification task python -u eval_genre.py checkpoints/checkpoint_last_genre_topmagd_x_checkpoint_last_musicbert_small.pt topmagd_data_bin/x", "type": "Bash Script", "id": 250, "prefix_code": "", "output": "python -u eval_genre.py checkpoints/checkpoint_last_genre_topmagd_x_checkpoint_last_musicbert_small.pt topmagd_data_bin/x"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 9, "path": "./pdaugment", "arguments": "{'pyfile': 'pdaugment.py', 'pickle_path': 'data/pickle/mel_splits.pickle', 'frequency_json_file': 'utils/frequency.json', 'dataset_dir': 'data/speech/wav/dev-clean', 'midi_file_fir': 'data/midis/processed/midi_6tracks', 'metadata_dir': 'data/speech/phone/dev-clean_metadata.csv', 'output_duration_dir': 'data/duration', 'output_pitch_dir': 'data/pitch', 'output_pdaugment_dir': 'data/pdaugment', 'number_of_threads': 16}", "instruction": "I am interested in performing Automatic Lyrics Transcription. For this purpose, I require some assistance in writing the code or script. The specific requirements are as follows:\n\n- The python file that needs to be used is \"pdaugment.py\".\n- The path for the pickle file is \"data/pickle/mel_splits.pickle\".\n- The frequency JSON file is located at \"utils/frequency.json\".\n- The dataset directory for the speech files is \"data/speech/wav/dev-clean\".\n- The MIDI files are stored in the directory \"data/midis/processed/midi_6tracks\".\n- The metadata for the speech files can be found in the directory \"data/speech/phone/dev-clean_metadata.csv\".\n- The output directory for the duration files should be set to \"data/duration\".\n- The output directory for the pitch files should be set to \"data/pitch\".\n- Additionally, I would like to specify the output directory for the pdaugment files as \"data/pdaugment\".\n- Lastly, I would like to run the code using 16 threads.\n\nCould you please assist me in writing the necessary code or script that fulfills these requirements?", "oracle": "You can augment the speech dataset with multiple threads by setting: number_of_threads       # number of threads to process, e.g., 16 Finally run the pdaugment.py. python pdaugment.py <pickle_path> <frequency_json_file> <dataset_dir> <midi_file_fir> <metadata_dir> <output_duration_dir> <output_pitch_dir> <output_pdaugment_dir> <number_of_threads> # e.g., python pdaugment.py data/pickle/mel_splits.pickle utils/frequency.json data/speech/wav/dev-clean data/midis/processed/midi_6tracks data/speech/phone/dev-clean_metadata.csv data/duration data/pitch data/pdaugment 16", "type": "Bash Script", "id": 251, "prefix_code": "", "output": "python pdaugment.py data/pickle/mel_splits.pickle utils/frequency.json data/speech/wav/dev-clean data/midis/processed/midi_6tracks data/speech/phone/dev-clean_metadata.csv data/duration data/pitch data/pdaugment 16"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 10, "path": "./clamp", "arguments": "{'pyfile': 'clamp.py', 'clamp_model_name': 'sander-wood/clamp-small-512', 'query_modal': 'text', 'key_modal': 'music', 'top_n': 5}", "instruction": "I am eager to perform a semantic music search using the script called clamp.py. The specified Clamp model name is sander-wood/clamp-small-512. To conduct the search, I will be utilizing text as the query modality and music as the key modality. It would be splendid if I could retrieve the top 5 results. Can you kindly assist me in writing the necessary code or script to accomplish this task?", "oracle": "Run the following command to perform the query: python clamp.py -clamp_model_name [MODEL NAME] -query_modal [QUERY MODAL] -key_modal [KEY MODAL] -top_n [NUMBER OF RESULTS] Replace [MODEL NAME] with the name of the CLaMP model you want to use (either sander-wood/clamp-small-512 or sander-wood/clamp-small-1024), [QUERY MODAL] with either music or text to indicate the type of query you want to perform, [KEY MODAL] with either music or text to indicate the type of key modal you want to use, and [NUMBER OF RESULTS] with the number of top results you want to return.", "type": "Bash Script", "id": 252, "prefix_code": "", "output": "python clamp.py -clamp_model_name sander-wood/clamp-small-512 -query_modal text -key_modal music -top_n 5"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 11, "path": "./songmass", "arguments": "{'bashfile': 'train.sh', 'data_dir': 'data_org/processed', 'user_dir': 'mass'}", "instruction": "I am interested in conducting Lyric-to-Melody and Melody-to-Lyric training utilizing the train.sh bash file. For this purpose, I require the following arguments: 'bashfile' should be set to 'train.sh', 'data_dir' should be set as 'data_org/processed', and 'user_dir' should be set as 'mass'. Could you kindly provide me with the necessary code or script to accomplish this task?", "oracle": "We provide an example script for running. data_dir=data_org/processed # The path of binarized data user_dir=mass bash train.sh $data_dir $user_dir", "type": "Bash Script", "id": 253, "prefix_code": "", "output": "bash train.sh data_org/processed mass"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 12, "path": "./songmass", "arguments": "{'bashfile': 'infer_lyric.sh', 'data_dir': 'data_org/processed', 'user_dir': 'mass', 'model': 'checkpoint_best.pt'}", "instruction": "I am interested in performing a lyric inference task. To accomplish this, I need to utilize the 'infer_lyric.sh' bash file. Additionally, I will require the 'data_org/processed' directory for data processing, and the 'mass' user directory for specific operations. For the model, I will be using the 'checkpoint_best.pt' file. Could you kindly assist me by writing the necessary code or script?", "oracle": "For lyric inference, the running script is as below: data_dir=data_org/processed user_dir=mass model=checkpoint_best.pt # your model path bash infer_lyric.sh  $data_dir $user_dir $model", "type": "Bash Script", "id": 254, "prefix_code": "", "output": "bash infer_lyric.sh  data_org/processed mass checkpoint_best.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 13, "path": "./songmass", "arguments": "{'bashfile': 'infer_melody.sh', 'data_dir': 'data_org/processed', 'user_dir': 'mass', 'model': 'checkpoint_best.pt'}", "instruction": "I am eager to embark on a thrilling musical journey of melody generation! To accomplish this, I need your assistance in creating the code or script. The bashfile required for this task is infer_melody.sh. Additionally, we will need to access the data directory located at data_org/processed, and the user directory named mass. Lastly, we must utilize the remarkable model named checkpoint_best.pt. With your guidance, we can create a mesmerizing melody-generating masterpiece!", "oracle": "For melody generation, the running script is as below: data_dir=data_org/processed user_dir=mass model=checkpoint_best.pt # your model path bash infer_melody.sh  $data_dir $user_dir $model", "type": "Bash Script", "id": 255, "prefix_code": "", "output": "bash infer_melody.sh  data_org/processed mass checkpoint_best.pt"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 14, "path": "./deeprapper", "arguments": "{'bashfile': 'generate_from_pretrain.sh'}", "instruction": "I am intrigued by the prospect of embarking on a Lyric Generation endeavor. In order to accomplish this task, I have come across a bash file called generate_from_pretrain.sh that could be of great assistance. Would you kindly lend your expertise in helping me construct the necessary code or script to bring this vision to life?", "oracle": "Finally, run the following command to generate: bash generate_from_pretrain.sh", "type": "Bash Script", "id": 256, "prefix_code": "", "output": "bash generate_from_pretrain.sh"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 15, "path": "./deeprapper", "arguments": "{'pyfile': 'generate.py', 'device': '0', 'length': '512', 'batch_size': '1', 'nsamples': '2', 'temperature': '1', 'topk': '8', 'topp': '0', 'repetition_penalt': '1.', 'save_samples': '', 'save_samples_dir': 'samples_save_dir', 'samples_sign': 'sample_name', 'model_dir': 'model/deeprapper-model', 'model_config': 'config.json', 'enable_final': '', 'enable_sentence': '', 'enable_relative_pos': '', 'enable_beat': '', 'prefix': '', 'with_beat': '', 'beat_mode': '', 'reverse': '', 'pattern': '', 'beam_sample_select_sg': 'sample', 'beam_cut_temperature': 10, 'dynamic_rhyme': '', 'rhyme_count': 1, 'rhyme_prob_bound': 1.0, 'rhyme_alpha': 0.95}", "instruction": "I am interested in generating lyrics using the file named 'generate.py'. For this task, I would like to set the device to '0' and the length of the lyrics to be generated to '512'. Additionally, I would like to set the batch size to '1', generate '2' samples with a temperature of '1', and use a top-k value of '8' with a top-p value of '0'. The repetition penalty should be set to '1.0'. \n\nFurthermore, I would like to save the generated lyrics with the sample name 'sample_name' in the directory 'samples_save_dir'. The model for lyric generation can be found in the 'model/deeprapper-model' directory, with the model configuration specified in 'config.json'. \n\nPlease make sure to enable the required features, such as 'enable_final', 'enable_sentence', 'enable_relative_pos', and 'enable_beat', as well as any other necessary options. \n\nThe lyrics generation process should not have any specific prefix, and there is no need to consider the beat while generating the lyrics. Additionally, there is no need to reverse the generated lyrics or follow a specific pattern. \n\nFor the beam search sampling method, please use the 'sample' selection strategy and set the beam cut temperature to '10'. \n\nRegarding the rhyming aspect, it is not necessary to enable the dynamic rhyme mode. However, if enabled, I would like to generate lyrics with '1' rhyme and ensure the rhyme probability bound is set to '1.0'. The rhyme alpha value should be set to '0.95'. \n\nCould you please assist me in writing the code or script to implement these settings?", "oracle": "You can specify the arguments in the bash file, such as number of epoch, bach size, etc. The trained model is saved in [model_dir]/lyrics/[raw_data_dir][_reverse]/[model_sign]/final_model. For example, in the default train.sh, the path is model/lyrics/lyrics_samples_reverse/samples/final_model. To generate by the trained DeepRapper, run bash generate.sh", "type": "Bash Script", "id": 257, "prefix_code": "", "output": "python generate.py --device '0' --length 512 --batch_size 1 --nsamples 2 --temperature 1 --topk 8 --topp 0 --repetition_penalty 1. --save_samples --save_samples_dir 'samples_save_dir' --samples_sign 'sample_name' --model_dir 'model/deeprapper-model' --model_config 'config.json' --enable_final --enable_sentence --enable_relative_pos --enable_beat --prefix '\u6211\u957f\u5927\u7684\u5730\u65b9\u50cf\u4e00\u4e2a\u7b80\u6734\u7684\u5be8' --with_beat --beat_mode 0 --reverse --pattern 'beam' --beam_sample_select_sg 'sample' --beam_cut_temperature 10 --dynamic_rhyme --rhyme_count 1 --rhyme_prob_bound 1.0 --rhyme_alpha 0.95"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 16, "path": "./roc", "arguments": "{'pyfile': 'lyrics_to_melody.py', 'lyrics_path': 'lyrics.txt', 'chord_path': 'chord.txt', 'db_path': 'database/ROC.db', 'debug': 'store_true', 'sentiment': 'store_true'}", "instruction": "I am looking to perform Lyric-to-Melody Generation using a Python file named \"lyrics_to_melody.py\". The necessary arguments include the path to the lyrics file (lyrics.txt), the path to the chords file (chord.txt), the path to the database (database/ROC.db), enabling the debug mode (store_true), and enabling sentiment analysis (store_true). Could you please assist me in writing the code or script to accomplish this task?", "oracle": "(2) Prepare lyrics data. Please write your lyrics in 'lyrics.txt', , one line for each song. Please set the lyrics language and a chord progression for each song in 'chord.txt'. Do not leave a space in the end of lines. We have provided bilingual examples in the two files. (3) Run the ROC: python lyrics_to_melody.py For each line in 'lyrics.txt', ROC generates a midi file named as the first sentence in lyrics.", "type": "Bash Script", "id": 258, "prefix_code": "", "output": "python lyrics_to_melody.py lyrics.txt chord.txt database/ROC.db store_true store_true"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 17, "path": "./meloform", "arguments": "{'bashfile': 'meloform_refine_melody.sh', 'data_dir': './data/refine/data_nn', 'song_id': 0, 'model_path': 'checkpoints/', 'res_dir': 'results/'}", "instruction": "I am interested in generating Music Forms, and for that, I require the execution of the meloform_refine_melody.sh bash script. Additionally, I would need to access the data directory located at ./data/refine/data_nn and specify the song ID as 0. The model path should be set to the checkpoints/ directory, and the resulting music forms should be stored in the results/ directory. Could you kindly assist me in writing the necessary code or script to achieve this task?", "oracle": "The processed results are under ./data/refine/data_nn/{song_id}, in ./data/refine/data_nn/{song_id}/template. Finally, run data_dir=./data/refine/data_nn song_id=0 model_path=checkpoints/ res_dir=results/ bash meloform_refine_melody.sh $data_dir $song_id $model_path $res_dir The final refined melody will be located in {res_dir}/out_midi/{song_id}/b1/src_res.mid", "type": "Bash Script", "id": 259, "prefix_code": "python process_es.py ./data/refine/expert_system 0 ./data/refine/data_nn", "output": "bash meloform_refine_melody.sh ./data/refine/data_nn 0 checkpoints/ results/"}
{"github_id": 14, "github": "https://github.com/microsoft/muzic", "repo_id": 18, "path": "./musecoco", "arguments": "{'bashfile': 'interactive_1billion.sh', 'start_idx': 0, 'end_idx': 200}", "instruction": "I am interested in exploring the realm of Text-to-Music Generation. For this endeavor, I have obtained a bashfile named interactive_1billion.sh. As part of the process, I would like to specify the start index as 0 and the end index as 200. Could you be so kind as to assist me in crafting the code or script required to achieve this objective?", "oracle": "Prepare the input for inference in the folder data/infer_input/infer_test.bin from the output of text-to-attribute understanding stage (infer_test.bin). Run the following command to generate music based on the first 200 samples in infer_test.bin. # The following script takes 'data/infer_input/infer_test.bin' as input. bash interactive_1billion.sh 0 200 # bash interactive.sh start_idx end_idx input_name", "type": "Bash Script", "id": 260, "prefix_code": "", "output": "bash interactive_1billion.sh 0 200"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 1, "path": "./segment_anything", "arguments": "{'image': 'pic3/pic3.jpg', 'prompts': 'output_pic3/picture3'}", "instruction": "I am interested in utilizing the segment anything demo to generate a mask for my input image. The path to my input image is \"ground_segment/GD_new.json\", and I would like to save the output mask to \"output_pic3/picture3\". Could you please assist me by writing the script required to accomplish this task?", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 261, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input pic3/pic3.jpg --output output_pic3/picture3"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 2, "path": "./segment_anything", "arguments": "{'image': 'picture/my_cat_mi.jpg', 'prompts': 'output_pic/mask_cat_mi_extract'}", "instruction": "I have a task where I need to utilize the segment anything demo in order to generate a mask for my input image. The path to my input image is \"ground_segment/GD_new.json\", and I would like the output mask to be saved at \"output_pic/mask_cat_mi_extract\". Could you kindly assist me in writing the script to accomplish this task? The required arguments are as follows: image path should be set to \"picture/my_cat_mi.jpg\", and the prompts path should be set to \"output_pic/mask_cat_mi_extract\".", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 262, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input picture/my_cat_mi.jpg --output output_pic/mask_cat_mi_extract"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 3, "path": "./GroundingDINO", "arguments": "{'i': '.asset/human.jpg', 'o': 'output/human_1', 't': 'all people'}", "instruction": "I am eager to employ the fascinating grounding dino demo for my upcoming project. The input image path that I have is \"ground_segment/GD_new.json\", and I would like the output to be saved in the directory \"output/human_1\". As for the text condition, I want it to be set as \"all people\". It would be immensely helpful if you could assist me by crafting a script that fulfills these requirements.", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 263, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/human.jpg -o output/human_1 -t \"all people\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 4, "path": "./GroundingDINO", "arguments": "{'i': '.asset/cat.jpg', 'o': 'output/cat2002', 't': 'right ear of cat'}", "instruction": "I am interested in utilizing the grounding dino demo for a specific task. The input image path is \"ground_segment/GD_new.json\", and I would like the output to be saved in the directory \"output/cat2002\". Additionally, I would like the text condition to be set to \"right ear of cat\". Could you kindly assist me in writing the script to achieve this?", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 264, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/cat.jpg -o output/cat2002 -t \"right ear of cat\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 5, "path": "./GroundingDINO", "arguments": "{'i': '.asset/moon1.jpg', 'o': 'output/moon10', 't': 'moon in pool'}", "instruction": "I am interested in utilizing the grounding dino demo. In order to execute this, I will need to provide the input image path as \"ground_segment/GD_new.json\" and the output path as \"output/moon10\". Additionally, I need to set the text condition to \"moon in pool\". Can you assist me by generating the necessary script for this task?", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 265, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/moon1.jpg -o output/moon10 -t \"moon in pool\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 6, "path": "", "arguments": "{'image': 'pathtoimage.jpg', 'prompts': 'all flowers.'}", "instruction": "I am interested in utilizing the grounding dino demo to accomplish a specific task. In order to proceed, I would require an image located at \"pathtoimage.jpg\" and the prompt \"all flowers.\" Could you kindly assist me by providing the necessary code to achieve this objective?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 266, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"pathtoimage.jpg\"\nTEXT_PROMPT = \"all flowers.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 7, "path": "./GroundingDINO", "arguments": "{'i': '.asset/dog.jpg', 'o': 'output/output_dog', 't': 'right ear of dog'}", "instruction": "I have a task at hand that involves utilizing the grounding dino demo. In order to accomplish this, I need to provide the following arguments: {'i': '.asset/dog.jpg', 'o': 'output/output_dog', 't': 'right ear of dog'}. The input image path is \"ground_segment/GD_new.json\" and the output path is \"output/output_dog\". Additionally, I need to specify the text condition as \"right ear of dog\". Could you kindly assist me in crafting the script required for this task?", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 267, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/dog.jpg -o output/output_dog -t \"right ear of dog\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 8, "path": "", "arguments": "{'image': 'image/dogs.jpg', 'prompts': 'all dogs.'}", "instruction": "I am interested in utilizing the grounding dino demo functionality to analyze an image with the path image/dogs.jpg. My prompt for the analysis is \"all dogs.\" Could you please assist me in writing the code to achieve this?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 268, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"image/dogs.jpg\"\nTEXT_PROMPT = \"all dogs.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 9, "path": "./segment_anything", "arguments": "{'image': 'pic2/picture2.jpg', 'prompts': 'output_pic2/picture2'}", "instruction": "I have a task where I need to utilize the \"segment anything demo\" feature to create a mask for my input image. The path of my input image is \"ground_segment/GD_new.json\" and I would like the output to be saved in the directory \"output_pic2/picture2\". Can you assist me in writing a script that accomplishes this?\n\nRequire arguments: \n- image: pic2/picture2.jpg\n- prompts: output_pic2/picture2\n\nOutput:\n1. I am currently working on a project that involves utilizing the \"segment anything demo\" functionality. My objective is to generate a mask for a specific input image. The path of the input image is \"ground_segment/GD_new.json\", and I would like the resulting mask to be saved in the directory \"output_pic2/picture2\". Could you please help me by writing the necessary script?\n\nNote: The format of the require arguments in the output has been modified to fit the given input.", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 269, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input pic2/picture2.jpg --output output_pic2/picture2"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 10, "path": "", "arguments": "{'image': 'image/tree.jpg', 'prompts': 'all trees.'}", "instruction": "I am interested in utilizing the grounding dino demo functionality to process an image. The image that I would like to use is located at the path image/tree.jpg. Additionally, I would like to set the prompt to \"all trees.\" Could you kindly assist me by providing the necessary code?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 270, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"image/tree.jpg\"\nTEXT_PROMPT = \"all trees.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 11, "path": "./segment_anything", "arguments": "{'image': 'picture/my_cat.jpg', 'prompts': 'output_pic/mask_cat'}", "instruction": "I have a task at hand where I need to utilize the segment anything demo to generate a mask for a specific input image. The path to the input image is \"ground_segment/GD_new.json\", and I would like the output mask to be saved at \"output_pic/mask_cat\". Can you kindly assist me in crafting the script required for this purpose? The necessary arguments for the script are as follows: {'image': 'picture/my_cat.jpg', 'prompts': 'output_pic/mask_cat'}.", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 271, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input picture/my_cat.jpg --output output_pic/mask_cat"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 12, "path": "./GroundingDINO", "arguments": "{'i': '.asset/moon.jpg', 'o': 'output/moon1', 't': 'moon in sky'}", "instruction": "I am interested in utilizing the grounding dino demo for my project. The input image path is \"ground_segment/GD_new.json\", and I would like the output to be saved in \"output/moon1\". Additionally, I would like to set the text condition to \"moon in sky\". Can you assist me in writing the script required for this task?\n\n2. I have a specific requirement for my project, and I believe the grounding dino demo will be a perfect fit. The input image path is \"ground_segment/GD_new.json\", and I would like the output to be saved in the directory \"output/moon1\". Moreover, I need the text condition to be set as \"moon in sky\". Could you kindly help me in writing the script needed to achieve this?\n\n3. My project involves utilizing the grounding dino demo. To accomplish this, I need to specify the input image path as \"ground_segment/GD_new.json\" and the output path as \"output/moon1\". Furthermore, I want to set the text condition as \"moon in sky\". It would be greatly appreciated if you could assist me in writing the script for this purpose.\n\n4. I have a fascinating project in mind, and I believe the grounding dino demo could be the perfect tool to achieve my goals. The input image path is \"ground_segment/GD_new.json\", and I would like the output to be saved in the directory \"output/moon1\". As for the text condition, I would like it to be set as \"moon in sky\". Could you please lend me your expertise in crafting the necessary script?\n\n5. In order to accomplish my project goals, I am in need of the grounding dino demo. The input image path I have is \"ground_segment/GD_new.json\", and the desired output path is \"output/moon1\". Additionally, I would like the text condition to be set as \"moon in sky\". I kindly request your assistance in writing the script required for this task.", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 272, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/moon.jpg -o output/moon1 -t \"moon in sky\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 13, "path": "", "arguments": "{'image': 'image/cats.jpg', 'prompts': 'all cats.'}", "instruction": "I am interested in utilizing the grounding dino demo for analyzing an image. The image I would like to use is located at the path \"image/cats.jpg\", and the prompt I want to provide is \"all cats.\" Could you assist me in crafting the necessary code to achieve this?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 273, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"image/cats.jpg\"\nTEXT_PROMPT = \"all cats.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 14, "path": "./segment_anything", "arguments": "{'image': 'pic/picture1.jpg', 'prompts': 'output_pic/picture1'}", "instruction": "I have a task where I need to utilize the segment anything demo to generate a mask for a specific input image. The path for my input image is \"ground_segment/GD_new.json\", and I would like the output to be saved at \"output_pic/picture1\". Could you kindly assist me in writing the script to accomplish this task? The required arguments include the image path, which is 'pic/picture1.jpg', and the prompts path, which is 'output_pic/picture1'.", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 274, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input pic/picture1.jpg --output output_pic/picture1"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 15, "path": "", "arguments": "{'image': 'image/0.jpg', 'prompts': 'all animals.'}", "instruction": "I am interested in utilizing the grounding dino demo functionality for my project. The image I would like to process is located at image/0.jpg, and the prompt I want to provide is \"all animals.\" Could you kindly assist me in writing the necessary code to achieve this task?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 275, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"image/0.jpg\"\nTEXT_PROMPT = \"all animals.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 16, "path": "", "arguments": "{'image': 'picture/my_cat_mi.jpg', 'prompts': 'cats.'}", "instruction": "I am interested in utilizing the grounding dino demo function to perform image grounding. The image I would like to use is located at the path \"picture/my_cat_mi.jpg\", and the prompt I want to provide is \"cats.\" Could you assist me by crafting the necessary code for this task?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 276, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"picture/my_cat_mi.jpg\"\nTEXT_PROMPT = \"cats.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 17, "path": "./GroundingDINO", "arguments": "{'i': '.asset/animals.jpg', 'o': 'output/output_animals', 't': 'all animals'}", "instruction": "I am interested in utilizing the grounding dino demo to process an input image located at \"ground_segment/GD_new.json\". The output should be saved to the directory \"output/output_animals\". Additionally, I would like to apply a text condition of \"all animals\". Could you kindly assist me in generating the necessary script for this task?\n\n2. My objective is to employ the grounding dino demo for the purpose of analyzing an input image. The image is stored at the path \"ground_segment/GD_new.json\". I would appreciate it if you could help me write a script that saves the output to the directory \"output/output_animals\" and applies the text condition \"all animals\".\n\n3. I have a specific requirement to use the grounding dino demo with an input image located at \"ground_segment/GD_new.json\". The resulting output should be saved to the directory \"output/output_animals\". Additionally, I need to apply a text condition that encompasses \"all animals\". Could you please assist me in creating a script that fulfills these requirements?\n\n4. The task at hand involves utilizing the grounding dino demo to process an input image. The image can be found at the path \"ground_segment/GD_new.json\". The desired output should be saved in the directory \"output/output_animals\". Furthermore, I need to specify a text condition that includes \"all animals\". I would greatly appreciate your help in writing the necessary script to achieve this.\n\n5. I am currently seeking assistance in writing a script that utilizes the grounding dino demo. The script should process an input image, which is located at \"ground_segment/GD_new.json\". The resulting output needs to be saved in the directory \"output/output_animals\". Additionally, a text condition of \"all animals\" should be applied. Could you kindly help me by creating the required script?", "oracle": "Demo\nCUDA_VISIBLE_DEVICES=6 python demo/inference_on_a_image.py -c /path/to/config -p /path/to/checkpoint -i .asset/cats.png -o \"outputs/0\" -t \"cat ear.\" [--cpu-only] # open it for cpu mode\nSee the demo/inference_on_a_image.py for more details.", "type": "Bash Script", "id": 277, "prefix_code": "cd GroundingDINO\npip install -e .\nmkdir model\ncd model\nwget https://github.com/IDEA-Research/GroundingDINO/blob/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\ncd ..", "output": "CUDA_VISIBLE_DEVICES=0 python demo/inference_on_a_image.py -c model/GroundingDINO_SwinT_OGC.py -p model/groundingdino_swint_ogc.pth -i .asset/animals.jpg -o output/output_animals -t \"all animals\" "}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 18, "path": "./segment_anything", "arguments": "{'image': 'picture/my_pic3.jpg', 'prompts': 'output_pic/picture_mine'}", "instruction": "I am interested in utilizing the segment anything demo to generate a mask for my input image. The path to my input image is \"ground_segment/GD_new.json\", and I would like the output to be saved in the folder \"output_pic/picture_mine\". Could you kindly assist me by providing the necessary script? The required arguments for the script are as follows: {'image': 'picture/my_pic3.jpg', 'prompts': 'output_pic/picture_mine'}. Thank you in advance for your help!", "oracle": "Additionally, masks can be generated for images from the command line:\n\npython scripts/amg.py --checkpoint <path/to/sam/checkpoint> --input <image_or_folder> --output <output_directory>\n", "type": "Bash Script", "id": 278, "prefix_code": "pip install git+https://github.com/facebookresearch/segment-anything.git /npip install opencv-python pycocotools matplotlib onnxruntime onnx\nmkdir model\ncd model\nwget https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\ncd ..", "output": "python scripts/amg.py --checkpoint model/sam_vit_h_4b8939.pth --input picture/my_pic3.jpg --output output_pic/picture_mine"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 19, "path": "", "arguments": "{'image': 'picture/my_dog.jpg', 'prompts': 'dogs.'}", "instruction": "I am interested in utilizing the grounding dino demo for image analysis. Specifically, I would like to provide an image located at picture/my_dog.jpg and use the prompt \"dogs.\" Could you kindly assist me in writing the code necessary to achieve this?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 279, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"picture/my_dog.jpg\"\nTEXT_PROMPT = \"dogs.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
{"github_id": 15, "github": "https://github.com/IDEA-Research/Grounded-Segment-Anything", "repo_id": 20, "path": "", "arguments": "{'image': 'image/image.jpg', 'prompts': 'all doors.'}", "instruction": "I have a specific requirement to utilize the grounding dino demo. To achieve this, I need to provide the following arguments: the image path, which should be 'image/image.jpg', and the prompt, which should be 'all doors.'. Can you assist me in generating the necessary code to accomplish this task?", "oracle": "\n  Running with Python (same as demo but you can run it anywhere after installing GroundingDINO)\nfrom groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"assets/demo1.jpg\"\nTEXT_PROMPT = \"bear.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)\n    ", "type": "Python Code", "id": 280, "prefix_code": "cd Grounded-Segment-Anything\nwget https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth", "output": "from groundingdino.util.inference import load_model, load_image, predict, annotate\nimport cv2\n\nmodel = load_model(\"GroundingDINO/groundingdino/config/GroundingDINO_SwinT_OGC.py\", \"./groundingdino_swint_ogc.pth\")\nIMAGE_PATH = \"image/image.jpg\"\nTEXT_PROMPT = \"all doors.\"\nBOX_THRESHOLD = 0.35\nTEXT_THRESHOLD = 0.25\n\nimage_source, image = load_image(IMAGE_PATH)\n\nboxes, logits, phrases = predict(\n    model=model,\n    image=image,\n    caption=TEXT_PROMPT,\n    box_threshold=BOX_THRESHOLD,\n    text_threshold=TEXT_THRESHOLD\n)\n\nannotated_frame = annotate(image_source=image_source, boxes=boxes, logits=logits, phrases=phrases)\ncv2.imwrite(\"annotated_image.jpg\", annotated_frame)"}
